### 一、基本数据类型

- 整型
  - int			4Byte
  - short int	2Byte
  - long int	4Byte
  
  无符号：unsigned int

- 实型
  - float			4Byte
  - double		8Byte
  - long double	32位CPU：12Byte 	64位CPU：16Byte

- 字符型
  - char			1Byte
  
  无符号：unsigned char
- 枚举

<br/>

### 二、指针类型

- 地址
  - 0xffffffff

<br/>

### 三、构造型

- 结构体数据类型
  - struct

<br/>

### 四、空类型

- void

<br/>

### 五、不同类型值运算补充

- 整形

> 有符号整型在跟无符号整型运算时，会被转换为无符号类型运算，实际上就是这个负数的(补码+1)；无符号类型源码反码补码相同，所以此时这个负数实际是该类型最大值相减加一。

例子：

```c_cpp
int main()
{
    unsigned int a = 6;
    int b = -20;
    // printf("%#x\n",a+b);
    (a+b>0)?puts(">0"):puts("<0");  // >0
    return 0;
}
```

- 字符型

> 输出 "<0" 的原因：
> 
> char 默认有符号：b = -20 合法且提升为 int 后保持负数。
> 
> 整数提升规则：a + b 的结果为 -14（有符号 int），比较 >0 为假。
> 
> 核心结论：代码输出结果依赖 char 的默认符号性，在标准编译环境中输出 "<0"。
> 
> 当 unsigned char 和 char 参与运算时，两者会被提升为 int：
> 
> unsigned char a = 6 提升为 int，值为 6。
> 
> char b = -20（有符号）提升为 int，值为 -20。

```c_cpp
int main()
{
    unsigned char a = 6;
    char b = -20;
    (a+b>0)?puts(">0"):puts("<0");  // <0
    return 0;
}
```
