#### 0x01、基础地址操作

<br/>

`&` ：取地址

<br/>

`*` :  解地址

<br/>

`arr[10]`  ：数组名为常量，不可修改

<br/>

#### 0x02、常用指针

<br/>

`char *p[3] = {"iofe","giohr","seyy"};`  ：指针数组，数组里都是指针，因为里面都是常量，存的是常量首字符地址

`char (*p)[5] = {"lkoo","oiow","hhsa"};` ：数组指针，指向数组的指针变量，每次加一即可指向下一行

`int *sum(int x,int y);` ：指针函数；返回值是一个指针

`int (*pfunc)(int,int) = NULL;` ：函数指针；函数的入口地址，这是指的是指针变量

<br/>

#### 0x03、数组名赋值运算细节

```c_cpp
#include <stdio.h>   

int main()   
{    
     int a[5]={1,2,3,4,5};  
     int *ptr=(int *)(&a+1);  
     printf("%d,%d",*(a+1),*(ptr-1));   
     return 0;  
}
```

这段代码的输出结果为`2,5`，其中第二个值`5`的由来与指针运算的类型密切相关。以下是详细解释：

1. **数组与指针的类型差异**：
   - `a`是`int[5]`类型的数组，通常使用`a`时它会退化为指向首元素（`a[0]`）的指针，类型为`int*`。
   - 但`&a`的类型是`int(*)[5]`（指向长度为5的数组的指针），其步长是整个数组的大小（`5*sizeof(int)`）。
2. **指针运算的关键步骤**：
   - `&a + 1`：由于`&a`的类型是`int(*)[5]`，`+1`会跳过整个数组，指向数组末尾之后的位置。
   - `(int*)(&a + 1)`：将指向数组末尾的指针强制转换为`int*`类型，此时`ptr`指向数组后的地址，但类型为`int*`，步长变为`sizeof(int)`。
   - `ptr - 1`：作为`int*`类型，`-1`会向前移动一个`int`大小，指向数组最后一个元素`a[4]`（值为5）。
3. **输出结果**：
   - `*(a + 1)`：等价于`a[1]`，值为2。
   - `*(ptr - 1)`：指向`a[4]`，值为5。

**结论**：  
`&a`的指针运算以整个数组为单位，而强制转换后的`int*`指针以单个元素为单位移动，因此`ptr-1`正确指向了数组末尾的5。这就是输出结果为`2,5`的原因。
