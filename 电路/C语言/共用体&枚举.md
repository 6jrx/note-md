- 常见写法

```c_cpp
typedef union {    // union关键字
  char a;
  int b;
  float c;
  char d[10];
} Union1;
```

在C语言中，`union`（联合体）和`enum`（枚举）是两种重要的数据类型，它们分别用于不同的场景，具有特定的规则和用途。以下是它们的详细说明及使用场景：

---

### **一、`union`（联合体）**

#### **1. 基本规则**

- **内存共享**：所有成员共享同一块内存空间，大小由最大成员决定。
- **对齐要求**：联合体的对齐要求等于其最大成员的对齐值。
- **初始化**：只能初始化第一个成员。
- **访问成员**：同一时间只能有效使用其中一个成员，修改一个成员会覆盖其他成员的值。
- **匿名联合**（C11支持）：可直接访问成员，无需通过联合变量名。

#### **2. 使用场景**

- **节省内存**：当多个数据不会同时使用时，用联合体减少内存占用。
  ```c_cpp
  union Data {
      int i;
      float f;
      char str[20];
  };
  // 同一时间只能存储一个值（int、float或字符串）
  ```
- **类型转换**：利用联合体实现二进制数据的多类型解释。
  ```c_cpp
  union Converter {
      uint32_t u32;
      uint8_t bytes[4];
  };
  // 将32位整数按字节拆分处理
  ```
- **协议解析**：解析网络数据包或文件格式时，同一位置可能存储不同类型数据。
  ```c_cpp
  union Packet {
      struct {
          uint8_t type;
          uint8_t data[16];
      } raw;
      struct {
          uint8_t type;
          int32_t value;
      } int_payload;
  };
  ```
- **变体记录**：结合`struct`和`enum`实现多态数据。
  ```c_cpp
  typedef enum { INT, FLOAT, STR } Type;
  struct Variant {
      Type type;
      union {
          int i;
          float f;
          char s[20];
      } value;
  };
  ```

#### **3. 注意事项**

- **未定义行为**：访问未初始化的成员或错误成员会导致不可预测结果。
- **平台依赖**：不同系统对字节序（大端/小端）的处理可能不同。
- **内存对齐**：需关注成员对齐，避免因填充字节导致意外问题。

---

### **二、`enum`（枚举）**

#### **1. 基本规则**

- **常量定义**：枚举常量是整型值，默认从0开始递增。
- **显式赋值**：可为常量显式指定值，后续未赋值的常量递增。
  ```c_cpp
  enum Week {
      Mon = 1,  // 显式赋值
      Tue,      // 自动为2
      Wed = 10,
      Thu       // 自动为11
  };
  ```
- **作用域**：枚举常量是全局的（C语言中无命名空间），可能与其他标识符冲突。
- **类型大小**：C11前枚举类型的大小由编译器决定（通常为`int`），C11支持指定底层类型：
  ```c_cpp
  enum Color : uint8_t { RED, GREEN, BLUE }; // C11允许指定类型
  ```

#### **2. 使用场景**

- **替代魔法数字**：用有意义的名称代替数字，提高代码可读性。
  ```c_cpp
  enum ErrorCode {
      OK = 0,
      FILE_NOT_FOUND = 1,
      PERMISSION_DENIED = 2
  };
  ```
- **状态机**：表示有限的状态集合。
  ```c_cpp
  enum State { IDLE, RUNNING, PAUSED, STOPPED };
  ```
- **选项标志**：通过位掩码组合多个选项（需显式赋值为2的幂）。
  ```c_cpp
  enum Flags {
      FLAG_A = 1 << 0, // 0b0001
      FLAG_B = 1 << 1, // 0b0010
      FLAG_C = 1 << 2  // 0b0100
  };
  int options = FLAG_A | FLAG_C; // 组合选项
  ```
- **增强类型安全**（有限）：尽管C的枚举本质是整型，但可逻辑上区分不同用途的值。
  ```c_cpp
  enum LogLevel { DEBUG, INFO, WARNING, ERROR };
  void log_message(enum LogLevel level, const char* msg);
  ```

#### **3. 注意事项**

- **类型兼容性**：枚举常量本质是整型，可能与其他整型混用导致逻辑错误。
- **作用域污染**：枚举常量是全局的，需注意命名冲突。
- **C11扩展**：若需固定枚举大小，应使用C11的`enum EnumName : type`语法。

---

### **三、联合体与枚举的结合使用**

结合`union`和`enum`可以实现类型安全的变体数据存储：

```c_cpp
typedef enum { INT_TYPE, FLOAT_TYPE, STR_TYPE } DataType;

struct VariantData {
    DataType type;
    union {
        int i;
        float f;
        char s[20];
    } value;
};

void print_variant(struct VariantData data) {
    switch (data.type) {
        case INT_TYPE:
            printf("Integer: %d\n", data.value.i);
            break;
        case FLOAT_TYPE:
            printf("Float: %f\n", data.value.f);
            break;
        case STR_TYPE:
            printf("String: %s\n", data.value.s);
            break;
    }
}
```

---

### **四、总结**

|**特性**|**`union`**|**`enum`**|
|--|--|--|
|**核心目的**|共享内存，存储不同类型数据|定义一组命名整型常量|
|**内存占用**|由最大成员决定|通常为`int`大小（可指定类型，C11）|
|**典型场景**|协议解析、类型转换、节省内存|状态码、选项标志、有限状态集合|
|**风险**|成员覆盖、未定义行为|作用域污染、隐式类型转换|

#### **使用建议**

1. **`union`适用场景**：需要灵活解释同一内存块时（如网络协议、硬件寄存器访问）。
2. **`enum`适用场景**：需提高代码可读性、管理固定集合的常量时。
3. **结合使用**：用`enum`标记`union`当前有效成员，实现安全的变体数据类型。
