### 1. 在嵌入式系统中，从堆中动态分配内存可能发生什么问题？

① 内存碎片化

		外部碎片

		内部碎片

② 确定性不足

		​​分配时间不确定​​

		行为不可预测

③ 内存耗尽风险

		有限的内存资源

		缺乏有效的恢复机制

		难以检测的泄漏​​

④ 多任务环境问题

		线程安全问题（标准malloc/free在多任务环境中需要加锁，影响性能）

		优先级反转风险（低优先级任务占用内存锁时，高优先级任务可能被阻塞）

		任务间干扰（一个任务的内存错误可能影响整个系统的内存池）

⑤ 调试困难

		内存泄漏

		野指针问题​

		​​重复释放

		边界溢出

**解决方案**

​​静态分配​​：启动时分配所有需要的内存

​​内存池/对象池​​：预分配固定大小的内存块

​​基于栈的分配​​：对于临时内存需求使用栈空间

​​自定义分配器​​：针对特定应用场景优化

​​内存监控工具​​：实现内存使用统计和泄漏检测

<br/>

### 2. static关键字的作用

① 修饰局部变量

		延长局部变量的生命周期，将变量放入静态内存区，只初始化一次。作用域仍然在该函数内部。

② 修饰全局变量

		限制作用域在当前源文件内部，无法被外部引用。避免命名冲突。

③ 修饰函数

		限制作用域在当前源文件内部，避免命名冲突。

<br/>

### 3. __interrupt关键字的作用

是嵌入式C编译器的扩展关键字，用于定义中断函数，而非普通函数

当使用__interrupt修饰函数时，编译器会：

① ​​**保存上下文**​​：自动保存被中断程序的寄存器状态

② **​​禁用中断**​​：有些编译器会自动在进入时禁用中断

③ **​​特殊返回**​​：使用中断专用返回指令

​​④ **恢复上下文**​​：退出时恢复寄存器状态

**重要注意事项**

​​① **无参数无返回值**​​：中断函数通常不应有参数和返回值

​​② **简短高效​​**：应尽量保持ISR代码简短，避免复杂操作

③ **共享数据保护**​​：与主程序共享的变量应声明为volatile

④ **避免阻塞**​​：不应调用可能阻塞的函数（如某些库函数）

​​⑤ **编译器差异**​​：不同编译器的语法和行为可能有差异

​​⑥ **中断标志处理**​​：通常需要手动清除硬件中断标志

<br/>

### 4. 算数转换规则

```c_cpp
void foo(void) {
    unsigned int a = 6;
    int b = -20;
    (a + b > 6) ? puts(">6") : puts("<=6");    // >6
}
```

 混合类型运算时，有符号类型会被转换成无符号来运算。