## USART寄存器

### 0x01、框图

![截图](pic/3d14220703ae5ec3f25913ca55c7eeaa.png)

<br/>

<br/>

### 0x02、字长

![截图](pic/d80bd02e11d480d6370c979475788f74.png)

<br/>

<br/>

### 0x03、SR状态寄存器

![截图](pic/ae3ad43b8d5ea4931b9ca0dc1dd1e408.png)

![截图](pic/c3e3aadd8b9c118b8bdf72727fd5d8fa.png)

![截图](pic/0c8fe61be00ac2e6348c3e86f9f100e2.png)

![截图](pic/316b58db3ce0353a9d863a02d842e3c1.png)

<br/>

<br/>

### 0x04、DR状态寄存器

![截图](pic/adf9fa6d40c8e3e0534adf4269e3cf7b.png)

<br/>

<br/>

### 0x05、波特率寄存器

![截图](pic/9bb3a159ff6260fcd8bf9a2c0ebd70c4.png)

![截图](pic/5d8aff2b7fe2c89b5bd257753ca50261.png)

<br/>

<br/>

### 0x06、控制寄存器1

![截图](pic/4952e7c42250196b749560057317f8d9.png)

![截图](pic/48dfbea690a11f3a623551b4ee434dc6.png)

![截图](pic/5d720dfffc466a45f6c05aca6279af98.png)

![截图](pic/0e9c19751b914f75ff5e47a33238d439.png)

<br/>

<br/>

### 0x07、控制寄存器2

![截图](pic/e20a2f29162db336758a0d53ee38a1cf.png)

![截图](pic/6eb766a9f9a7d1136d9e4de85d0d33a2.png)

<br/>

### 0x08、波特率计算

![截图](pic/2fb4b727d20b987ac4dc2bfc0239408b.png)

计算出波特率DIV：`USARTDIV = FCK/(8*(2-OVER8)*波特率)`

```c_cpp
float usart1div = 84000000.0/(16*baud);
u32 Mantissa = (u32)usart1div;//整数部分
u32 Fraction = (u32)((usart1div - Mantissa)*16);
USART1->BRR = (Mantissa<<4)|Fraction;
```

**简化公式**

> 波特率写入值 = FCK / 波特率            //适用16倍采样率
> 
> 波特率写入值 = FCK / 波特率 * 2       //适用8倍采样率

<br/>

<br/>

## 配置使用步骤

<br/>

### 0x01、使能/波特率/协议配置

GPIO：包含两个IO口，一个发送一个接收。复用模式

USART：波特率、过采样、字长、停止位、奇偶校验、数据位

```c_cpp
//打开时钟
RCC->AHB1ENR |= (1<<0);
RCC->APB2ENR |= (1<<4);
//配置GPIO
GPIOA->MODER &= ~(0xf<<18);
GPIOA->MODER |= (0xa<<18);
//推挽
GPIOA->OTYPER &= ~(0x3<<9);
//快速模式
GPIOA->OSPEEDR &= ~(0xf<<18);
GPIOA->OSPEEDR |= (0xa<<18);
//选择复用为USART1
GPIOA->AFR[1] &= ~(0xff<<4);
GPIOA->AFR[1] |= (0x77<<4);

//-----------------------------------------------------

//USART1
float usart1div = 84000000.0/(16*baud);
u32 Mantissa = (u32)usart1div;//整数部分
u32 Fraction = (u32)((usart1div - Mantissa)*16);
USART1->CR1 &= ~(1<<15);//16倍过采样

USART1->BRR = (Mantissa<<4)|Fraction;
USART1->CR1 &= ~(1<<12); //字长8
USART1->CR1 &= ~(1<<10);//不启用校验位
USART1->CR2 &= ~(0x3<<12);//1个停止位
USART1->CR1 |= (0x3<<2);//使能发送器和接收器
USART1->CR1 |= (0x1<<13);//使能USART1
```

<br/>

### 0x02、读取与写入寄存器

操作USART串口的`SR`与`DR`

```c_cpp
// USART1接收一个字符
u8 USART1_RecvChar(void)
{
    while (!(USART1->SR & 1 << 5))
        ;
    return USART1->DR;
}

// USART2发送一个字符
void USART2_SendChar(u8 data)
{
    while (!(USART2->SR & 1 << 6))
        ;
    USART2->DR = data;
}
```
