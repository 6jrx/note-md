## ä¸€ã€åˆ·å…¥åˆå§‹å‡ºå‚å›ºä»¶

å‡†å¤‡å·¥å…·ï¼š`AndroidTool.exe`

![](img\010.png)

è¿›å…¥åˆ·æœºæ¨¡å¼

- normalæ¨¡å¼ï¼šæ­£å¸¸å¯åŠ¨

- loaderæ¨¡å¼ï¼šå‡çº§å†…æ ¸æ—¶
    - å‘½ä»¤ï¼š`reboot loader`
    - æŒ‰é”®ï¼š æŒ‰ä½`recovery`é”®ä¹‹åå†æŒ‰ä¸‹`reset`é”®ç­‰3-5ç§’

- maskromæ¨¡å¼ï¼šåˆ·å…¥å®Œå…¨ç‰ˆå›ºä»¶ï¼Œå®Œå…¨åˆå§‹åŒ–ã€‚åŒ…æ‹¬æ‰€æœ‰éœ€è¦åˆ·å…¥socçš„å†…å®¹


å¼€å§‹æ“ä½œåˆ·å…¥

1. è¿›å…¥loader

```bash
reboot loader
```

2. ç”¨è½¯ä»¶è¿›å…¥maskrom

![](img\011.png)

3. æ‰§è¡Œé»˜è®¤çš„åˆ·æœºè¡Œä¸º

![](img\012.png)

> ç¡®ä¿å›ºä»¶æ–‡ä»¶éƒ½åœ¨åŒç›®å½•ä¸‹

åˆ·å…¥å›ºä»¶åè‡ªåŠ¨é‡å¯

è´¦å·å¯†ç ï¼š`root` `fa`


## äºŒã€äº¤å‰ç¼–è¯‘å·¥å…·é“¾

ç¼–è¯‘å·¥å…·ï¼šgcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu

ä¸‹è½½åœ°å€ï¼š`https://releases.linaro.org/components/toolchain/binaries/`

é…ç½®å·¥å…·é“¾åˆ°è™šæ‹Ÿæœºç¯å¢ƒä¸­

1. æ·»åŠ åˆ°ç¯å¢ƒå˜é‡

```bash
export PATH=~/gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu/bin:$PATH
```
æˆ–è€…ä¿®æ”¹ç”¨æˆ·é»˜è®¤ç¯å¢ƒé…ç½®æ–‡ä»¶`.bashrc`å’Œ`.zshrc`ï¼Œ`.profile`æ–‡ä»¶ä¹Ÿå¯ä»¥ï¼Œéœ€è¦æ³¨æ„æ˜¯å¦ç”¨æˆ·ç™»å½•ç¯å¢ƒ
```bash
source ~/.zshrc
```

2. æ£€æŸ¥æ˜¯å¦ç”Ÿæ•ˆ

```bash
aarch64-linux-gnu-gcc -v
```

3. äº¤å‰ç¼–è¯‘æ ‡å‡†Cç¨‹åº

```makefile
CC = aarch64-linux-gnu-gcc
CFLAGS = -Wall -g -O0
SRC = $(shell ls *.c)
APP = $(patsubst %.c, %, $(SRC))

all: $(APP)

%: %.c
	$(CC) $(CFLAGS) -o %@ %<

install: 
	scp $(APP) root@192.168.2.122:/code_drv

clean:
	$(RM) $(APP)

.PHONY: clean
```

## ä¸‰ã€å†…æ ¸ç¼–è¯‘

å†…æ ¸åŒ…é€šå¸¸ç”±å¼€å‘æ¿å‚å•†æä¾›ï¼Œåº”ä¸ºæ¿è½½ç”µè·¯åŠŸèƒ½ç»ç”±ä»–ä»¬ä¿®æ”¹å®šåˆ¶åï¼Œå†…æ ¸åŠŸèƒ½æ¨¡å—éšä¹‹éœ€è¦æ”¹å˜

æ¡ˆä¾‹å¼€å‘æ¿æ‰‹å†Œï¼š`https://wiki.friendlyelec.com/wiki/index.php/NanoPC-T4/zh`

### 1.å®‰è£…ä¾èµ–

ubuntuç¯å¢ƒå¯èƒ½éœ€è¦å®‰è£…ä»¥ä¸‹ä¾èµ–åŒ…

```bash
sudo apt install libssl-dev liblz4-tool gcc-multilib libncurses5-dev
```

### 2.å¤„ç†å†…æ ¸ç¼–è¯‘é…ç½®

ä½¿ç”¨å¼€å‘æ¿å‚å•†çš„é…ç½®æ–‡ä»¶
```bash
cd ~/kernel-rockchip-nanopi4-linux-v4.4.y
rm .config
cp arch/arm64/configs/nanopi4_linux_defconfig .config
```

### 3.é€‰æ‹©æ€§å¯¹å†…æ ¸é…ç½®è¿›è¡Œä¿®æ”¹

ä½¿ç”¨makeå¯¹.configè¿›è¡ŒGUIå¯è§†åŒ–é…ç½®ä¿®æ”¹
```bash
make menuconfig
```
![](img\013.png)

### 4.åˆ›å»ºä¸€ä¸ªæ–¹ä¾¿ç¼–è¯‘çš„è„šæœ¬

```shell
#!/bin/bash

make ARCH=arm64 nanopi4-images -j6
```

### 5.ç¼–è¯‘å†…æ ¸

```bash
# make distclean æ¸…ç†æ›´å½»åº•ï¼ŒåŒ…å«é…ç½®æ–‡ä»¶ï¼›distclean > mrproper > clean
make clean
./mymake.sh
```

### 6.çƒ§å½•å†…æ ¸æ¨¡å—

åœ¨çƒ§å½•è½¯ä»¶å†…åªé€‰ä¸­`kernel.img`è·Ÿ`resource.img`

![](img\014.png)

## å››ã€é©±åŠ¨ç¼–å†™ä¸å®‰è£…

ä¸ºäº†æ–¹ä¾¿ç´¢å¼•linuxæºç å·¥ç¨‹ï¼Œæ¨èä½¿ç”¨`Source Insight4.0`ä»£ç ç¼–è¾‘å·¥å…·ï¼Œç°é˜¶æ®µvscodeé…ç½®ç¨æ˜¾éº»çƒ¦

### 1.ç¼–å†™Makefileæ–‡ä»¶

```makefile
#æŒ‡å®šå†…æ ¸æºç çš„ä¸»ç›®å½•
KERN_DIR = /home/robin/work/kernel-rockchip-nanopi4-linux-v4.4.y

#æŒ‡å®šæ¨¡å—ç¨‹åºæ–‡ä»¶æ‰€åœ¨çš„ç›®å½•
CUR_DIR = $(shell pwd)

all:
	make -C $(KERN_DIR) M=$(CUR_DIR) modules

clean:
	make -C $(KERN_DIR) M=$(CUR_DIR) clean

install:
	scp *.ko root@192.168.2.123:/drv_code

#æŒ‡å®šå½“å‰ç›®å½•ä¸‹é‚£äº›æ–‡ä»¶ä½œä¸ºæ¨¡å—ç¨‹åºæ¥ç¼–è¯‘
obj-m = hello_drv.o
```

### 2.ç¼–å†™åŸºç¡€ä»£ç 

```c
#include <linux/module.h>
#include <linux/init.h>

// åˆå§‹åŒ–å‡½æ•°å®ç°ï¼Œ__initå‘Šè¯‰å†…æ ¸åªè°ƒç”¨ä¸€æ¬¡å°±é‡Šæ”¾è¯¥å‡½æ•°
static int __init hello_init(void)
{
	printk("call hello_init");
	printk("begin run hello");
	return 0;
}
// æ•ˆæœåŒä¸Š
static void __exit hello_exit(void)
{
	printk("call hello_exit");
}

module_init(hello_init); //å…¥å£å‡½æ•°
module_exit(hello_exit);  //å‡ºå£å‡½æ•°
MODULE_LICENSE("GPL"); //å£°æ˜ä½¿ç”¨å¼€æºåè®®
```

### 3.ç¼–è¯‘ä¸Šä¼ åˆ°å¼€å‘æ¿

```bash
make all
make install
```

### 4.åœ¨å¼€å‘æ¿å®‰è£…é©±åŠ¨æ¨¡å—

```bash
# æŸ¥çœ‹å†…æ ¸æ—¥å¿—ç­‰çº§
cat /proc/sys/kernel/printk
# ä¿®æ”¹å†…æ ¸æ—¥å¿—ç­‰çº§
echo 8 > /proc/sys/kernel/printk
# å®‰è£…é©±åŠ¨
insmod helle_drv.ko
# æŸ¥çœ‹é©±åŠ¨
lsmod
# å¸è½½é©±åŠ¨
rmmod helle_drv
```

### 5.é¢å‘å¯¹è±¡ç‰ˆæœ¬

```c
#include <linux/module.h>
#include <linux/init.h>
#include <linux/fs.h>
#include <linux/device.h>
#include <linux/slab.h>

/*
 *      udevæœºåˆ¶åˆ›å»ºè®¾å¤‡æ–‡ä»¶
 *      å†™å®¹é”™å¤„ç†
 *      é¢å‘å¯¹è±¡
 */

//å£°æ˜ä¸€ä¸ªhelloè®¾å¤‡çš„ç»“æ„ä½“(ç±»)
typedef struct rk_hello_drv {
        unsigned int major;
        struct class *cls;
        struct device *dev;
} hello_drv;

//å®šä¹‰å…¨å±€ç»“æ„ä½“å˜é‡
static hello_drv  *hello_device; //å£°æ˜ä¸€ä¸ªå¯¹è±¡ä¸ºhello_drvçš„æŒ‡é’ˆ

//å£°æ˜openå‡½æ•°
static int hello_open(struct inode *inode, struct file *filp);

//å£°æ˜closeå‡½æ•°
static int hello_close (struct inode *inode, struct file *filp);

//å®šä¹‰file_operationsç»“æ„ä½“ï¼Œå¹¶æŒ‡å®šæ–‡ä»¶æ“ä½œæ¥å£çš„å‡½æ•°æŒ‡é’ˆ
static struct file_operations fops = {
        .owner = THIS_MODULE, //é¿å…åœ¨ä½¿ç”¨æ—¶å¸è½½æ¨¡å—
        .open = hello_open,
        .release = hello_close,
};

//å®šä¹‰openå‡½æ•°
static int hello_open(struct inode *inode, struct file *filp)
{
        printk("call %s() @ %d\n", __func__, __LINE__);
        return 0;
}

//å®šä¹‰closeå‡½æ•°
static int hello_close (struct inode *inode, struct file *filp)
{
        printk("call %s() @ %d\n", __func__, __LINE__);
        return 0;
}

//é©±åŠ¨å®šä¹‰åˆå§‹åŒ–å‡½æ•°
static int __init hello_init(void)
{
        int ret;
        //ç”³è¯·å†…æ ¸å†…å­˜ç©ºé—´
        hello_device = kmalloc(sizeof(hello_drv), GFP_KERNEL);
        if (!hello_device) {
                printk("kmalloc fail\n");
                return -ENOMEM;
        }

        //1.æ³¨å†Œå­—ç¬¦è®¾å¤‡
        hello_device->major = register_chrdev(0, "hello_drv", &fops);
        if (hello_device->major < 0) {
                printk("<kernel> register_chrdev fail\n");
                ret = -EBUSY;
                goto err_register_chrdev;
        }

        printk("<kerenl> major=%d\n", hello_device->major);


        //2.åˆ›å»ºè®¾å¤‡ç±»å¯¹è±¡
        hello_device->cls = class_create(THIS_MODULE, "hello_cls");
        if (IS_ERR(hello_device->cls)) { //æµ‹è¯•åˆ›å»ºæ˜¯å¦æˆåŠŸ,æˆç«‹å°±å¤±è´¥
                ret = PTR_ERR(hello_device->cls);
                goto err_class_create;
        }

        //3.åˆ›å»ºè®¾å¤‡å¯¹è±¡(è®¾å¤‡æ–‡ä»¶)
        hello_device->dev = device_create(hello_device->cls, NULL, MKDEV(hello_device->major, 0), NULL, "hello");
        if (IS_ERR(hello_device->dev)) {
                ret = PTR_ERR(hello_device->dev);
                goto err_device_create;
        }

        printk("call %s() @ %d for oo\n", __func__, __LINE__);
        return 0;

    	// æ³¨æ„ï¼šæ¸…ç†èµ„æºé‡Šæ”¾æ—¶è¦éµå¾ªâ€œå…ˆè¿›åå‡ºâ€ï¼Œé¿å…é€ æˆé‡æŒ‡é’ˆ
err_device_create:
        class_destroy(hello_device->cls);

err_class_create:
        unregister_chrdev(hello_device->major, "hello_drv");

err_register_chrdev:
        kfree(hello_device);

        return ret;
}

static void __exit hello_exit(void)
{
        //é‡Šæ”¾èµ„æºï¼Œæ³¨æ„â€œå…ˆè¿›åå‡ºâ€å¼é‡Šæ”¾èµ„æº
        device_destroy(hello_device->cls, MKDEV(hello_device->major, 0));
        class_destroy(hello_device->cls);
        unregister_chrdev(hello_device->major, "hello_drv");
        kfree(hello_device);
        printk("call %s() @ %d\n", __FUNCTION__, __LINE__);
}


//å®šä¹‰é©±åŠ¨å…¥å£
module_init(hello_init);
//å®šä¹‰é©±åŠ¨å‡ºå£
module_exit(hello_exit);
//ä½¿ç”¨å¼€æºåè®®
MODULE_LICENSE("GPL");
```



### 6.æ–°ç‰ˆåˆ›å»ºè®¾å¤‡çš„å‡½æ•°

**`register_chrdev_region`**ï¼šé™æ€æŒ‡å®šè®¾å¤‡

**`alloc_chrdev_region`**ï¼šåŠ¨æ€åˆ†é…è®¾å¤‡å·

```c
#include <linux/fs.h>

// fromï¼šèµ·å§‹è®¾å¤‡å·ï¼ˆä¸»+æ¬¡ï¼‰ï¼Œå¦‚ MKDEV(200, 0)
// countï¼šè¦åˆ†é…çš„è¿ç»­è®¾å¤‡å·æ•°é‡
// nameï¼šè®¾å¤‡åç§°ï¼ˆåœ¨ /proc/devices ä¸­æ˜¾ç¤ºï¼‰
int register_chrdev_region(dev_t from, unsigned count, const char *name);
// devï¼šè¾“å‡ºå‚æ•°ï¼Œç”¨äºè¿”å›å†…æ ¸åˆ†é…çš„èµ·å§‹è®¾å¤‡å·
// baseminorï¼šèµ·å§‹æ¬¡è®¾å¤‡å·ï¼ˆé€šå¸¸ä¸º 0ï¼‰
int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name);
// è¿”å›0 è¡¨ç¤ºæˆåŠŸï¼Œè´Ÿå€¼è¡¨ç¤ºé”™è¯¯ï¼ˆå¦‚ -EBUSY è¡¨ç¤ºè®¾å¤‡å·å·²è¢«å ç”¨ï¼‰ã€‚
```

`cdev`ç»“æ„ä½“

```c
struct cdev {
	struct kobject kobj;
	struct module *owner;
	const struct file_operations *ops;
	struct list_head list;
	dev_t dev;
	unsigned int count;
};
```

**`cdev_alloc`**

```c
// ä½œç”¨ï¼šåœ¨å†…æ ¸å †ä¸ŠåŠ¨æ€åˆ†é…ä¸€ä¸ª struct cdev å¯¹è±¡ï¼Œå¹¶åˆå§‹åŒ–å…¶å†…éƒ¨å­—æ®µï¼ˆå¦‚ kobjï¼‰ã€‚
// è¿”å›å€¼ï¼šæˆåŠŸè¿”å›æŒ‡å‘ cdev çš„æŒ‡é’ˆï¼›å¤±è´¥è¿”å› NULLã€‚
// ç‰¹ç‚¹ï¼š
//     åˆ†é…çš„å†…å­˜éœ€ç”±é©±åŠ¨è´Ÿè´£é‡Šæ”¾ï¼ˆé€šè¿‡ cdev_del() è‡ªåŠ¨é‡Šæ”¾ï¼‰ã€‚
//     ä¸ä¼šåˆå§‹åŒ– .ops å’Œ .ownerï¼Œéœ€åç»­æ‰‹åŠ¨è®¾ç½®ã€‚
struct cdev *cdev_alloc(void);
```



ç¤ºä¾‹

```c
#include <linux/module.h>
#include <linux/init.h>
#include <linux/fs.h>
#include <linux/device.h>
#include <linux/slab.h>
#include <linux/gpio.h>
#include <linux/uaccess.h>
#include <linux/cdev.h>
#include <linux/interrupt.h>

/*
 * çœç•¥é‡å¤ä»£ç 
 */

//å£°æ˜ä¸€ä¸ªbottonè®¾å¤‡çš„ç»“æ„ä½“(ç±»)
typedef struct rk_botton_drv{
	unsigned int major;   			//ä¸»è®¾å¤‡å·
	struct class *cls;				//è®¾å¤‡ç±»
	struct device *dev;				//è®¾å¤‡
	unsigned int gpio_botton; 		//bottonå¼•è„šGPIO0_A5
	int gpio_irq_num;				//å¼•è„šä¸­æ–­å·
	dev_t devno;					//ä¿å­˜è®¾å¤‡å·
	struct cdev *cd;  				//å­—ç¬¦è®¾å¤‡æ ¸å¿ƒ
} botton_drv;

//å®šä¹‰å…¨å±€ç»“æ„ä½“å˜é‡
static botton_drv *botton_device; //å£°æ˜ä¸€ä¸ªå¯¹è±¡ä¸ºbotton_drvçš„æŒ‡é’ˆ

static int __init botton_init(void) 
{
	int ret;
	//ç”³è¯·å†…æ ¸å†…å­˜ç©ºé—´
	botton_device = kmalloc(sizeof(botton_drv), GFP_KERNEL);
	if (!botton_device) {
		printk("kmalloc fail\n");
		return -ENOMEM;
	}

#ifdef C_DIV
	//1.æ³¨å†Œå­—ç¬¦è®¾å¤‡
	botton_device->major = register_chrdev(0, "botton_drv", &fops);
	if (botton_device->major < 0) {
		printk("<kernel> register_chrdev fail\n");
		ret = -EBUSY;
		goto err_register_chrdev;
	}
#else
	//1.æ–°çš„æ³¨å†Œå­—ç¬¦è®¾å¤‡çš„æ–¹æ³•
	//åˆ†é…è®¾å¤‡å·
	if(alloc_chrdev_region(&botton_device->devno, 32, 1, "botton_drv"))
	{
		printk("alloc_chrdev_region fail\n");
		ret = -EBUSY;
		goto err_register_chrdev;
	}
	//è§£æå‡ºä¸»è®¾å¤‡å·; è§£ææ¬¡è®¾å¤‡å·ç”¨MINOR(botton_device->devno)
	botton_device->major = MAJOR(botton_device->devno);
	//åˆ›å»ºcdevå¯¹è±¡
	botton_device->cd = cdev_alloc();
	//åˆå§‹åŒ–cdevå¯¹è±¡
	cdev_init(botton_device->cd, &fops);
	//æ³¨å†Œcdevå¯¹è±¡
	cdev_add(botton_device->cd, botton_device->devno, 1);
#endif
	printk("<kerenl> major=%d\n", botton_device->major);

	//2.åˆ›å»ºè®¾å¤‡ç±»å¯¹è±¡
	botton_device->cls = class_create(THIS_MODULE, "botton_cls");
	if (IS_ERR(botton_device->cls)) { //æµ‹è¯•åˆ›å»ºæ˜¯å¦æˆåŠŸ,æˆç«‹å°±å¤±è´¥
		ret = PTR_ERR(botton_device->cls);
		goto err_class_create;
	}
	
	//3.åˆ›å»ºè®¾å¤‡å¯¹è±¡(è®¾å¤‡æ–‡ä»¶)
	botton_device->dev = device_create(botton_device->cls, NULL, botton_device->devno, NULL, "botton");
	if (IS_ERR(botton_device->dev)) {
		ret = PTR_ERR(botton_device->dev);
		goto err_device_create;
	}

	//4.ä»gpioå­ç³»ç»Ÿç”³è¯·èµ„æº
	botton_device->gpio_botton = 5;
	if (gpio_request(botton_device->gpio_botton, "botton_irq")) {
		printk("gpio_request fail\n");
		ret = -EBUSY;
		goto err_gpio_request;
	}

	//5.è·å¾—ä¸­æ–­å·
	botton_device->gpio_irq_num = gpio_to_irq(botton_device->gpio_botton);

	//6.æ³¨å†Œä¸­æ–­
	if((ret = request_irq(botton_device->gpio_irq_num, button_handler, 
		IRQF_TRIGGER_FALLING|IRQF_TRIGGER_RISING, "power_key_irq", NULL)))
	{
		printk("request_irq fail\n");
		ret = -EINVAL;
		goto err_request_irq;
	}

	printk("call %s() @ %d for oo init done. irq: %d\n", __func__, __LINE__, botton_device->gpio_irq_num);
	return 0;

err_request_irq:
	gpio_free(botton_device->gpio_botton);
err_gpio_request:
	device_destroy(botton_device->cls, botton_device->devno);
err_device_create:
	class_destroy(botton_device->cls);
err_class_create:
#ifdef C_DIV
    unregister_chrdev(botton_device->major, "botton_drv");
#else    
	cdev_del(botton_device->cd);
    unregister_chrdev_region(botton_device->devno, 1);  //é‡Šæ”¾è®¾å¤‡å·
#endif
err_register_chrdev:
	kfree(botton_device);

	return ret;
}
```





## äº”ã€é©±åŠ¨å¼€å‘å¸¸ç”¨å‡½æ•°å’Œå®

### **å®å®šä¹‰**

#### **`__FUNCTION__`**

å‡½æ•°åå˜é‡



#### **`__func__`**

åŒä¸Šï¼Œå‡½æ•°åå˜é‡



#### **`__LINE__`**

è¡Œå·å˜é‡

```c
printk("call %s of %d\n", __FUNCTION__, __LINE__);
```



#### **`THIS_MODULE`**

æŒ‡å‘å½“å‰é©±åŠ¨æ¨¡å—çš„æŒ‡é’ˆ

```c
static struct file_operations fops = {
	.owner = THIS_MODULE, //é¿å…åœ¨ç”¨æ—¶å¸è½½æ¨¡å—
	.open = led_open,
	.write = led_write,
	.release = led_close,
};
```



#### **`current`**

è¿›ç¨‹æè¿°ç¬¦å¯¹è±¡ï¼Œå¸¸ç”¨äºåœ¨å¤šè¿›ç¨‹ä¸­è¾“å‡º`current->pid`å’Œ`current->comm`

```c
#define current get_current()

static __always_inline struct task_struct *get_current(void)
{
	unsigned long sp_el0;
	asm ("mrs %0, sp_el0" : "=r" (sp_el0));
	return (struct task_struct *)sp_el0;
}
```





### **å‡½æ•°**

#### **`copy_from_user`**

æ‹·è´ç”¨æˆ·ç©ºé—´çš„æ•°æ®åˆ°å†…æ ¸ç©ºé—´

```c
#include <linux/uaccess.h>

//ä»ç”¨æˆ·æ€æ‹·è´åˆ°å†…æ ¸æ€
//    toï¼šå†…æ ¸ç©ºé—´çš„ç›®æ ‡åœ°å€
//    fromï¼šç”¨æˆ·ç©ºé—´çš„æºåœ°å€ï¼ˆç”±ç”¨æˆ·ç¨‹åºæä¾›ï¼‰
//    nï¼šè¦æ‹·è´çš„å­—èŠ‚æ•°
unsigned long copy_from_user(void *to, const void __user *from, unsigned long n)
```

- `__user` æ˜¯ä¸€ä¸ªç¼–è¯‘æ—¶æ³¨è§£ï¼ˆannotationï¼‰ï¼Œç”¨äºæç¤ºè¯¥æŒ‡é’ˆæŒ‡å‘ç”¨æˆ·ç©ºé—´ï¼Œä¸å…·æœ‰ç›´æ¥è®¿é—®æƒé™ã€‚
- ä¸¤ä¸ªå‡½æ•°è¿”å›å€¼éƒ½æ˜¯ **æœªæˆåŠŸæ‹·è´çš„å­—èŠ‚æ•°**ï¼ˆå³å¤±è´¥çš„å­—èŠ‚æ•°ï¼‰ï¼š
  - å¦‚æœè¿”å›å€¼ä¸º 0ï¼Œè¡¨ç¤º**å…¨éƒ¨æ‹·è´æˆåŠŸ**ã€‚
  - å¦‚æœè¿”å›å€¼ > 0ï¼Œè¡¨ç¤º**éƒ¨åˆ†æˆ–å…¨éƒ¨æ‹·è´å¤±è´¥**ï¼ˆé€šå¸¸æ˜¯å› ä¸ºç”¨æˆ·ç©ºé—´åœ°å€æ— æ•ˆï¼‰ã€‚


ç¤ºä¾‹

```c
ssize_t my_write (struct file *filp, const char __user *buf, size_t size, loff_t *flag)
{
	int ret;
	led_device->value = 0;
	ret = copy_from_user(&led_device->value, buf, size);
	if (ret) {
		printk("copy_from_user fail\n");
		return -EFAULT;
	}
    return 0;
}
```



#### **`copy_to_user`**

**å†…æ ¸ç©ºé—´**ä¸**ç”¨æˆ·ç©ºé—´**ä¹‹é—´å®‰å…¨åœ°æ‹·è´æ•°æ®

```c
#include <linux/uaccess.h>

//ä»å†…æ ¸æ€æ‹·è´åˆ°ç”¨æˆ·æ€
//    toï¼šç”¨æˆ·ç©ºé—´çš„ç›®æ ‡åœ°å€ï¼ˆç”±ç”¨æˆ·ç¨‹åºæä¾›ï¼‰
//    fromï¼šå†…æ ¸ç©ºé—´çš„æºåœ°å€
//    nï¼šè¦æ‹·è´çš„å­—èŠ‚æ•°
unsigned long copy_to_user(void __user *to, const void *from, unsigned long n);
```

ç¤ºä¾‹

```c
ssize_t my_read(struct file *file, char __user *buf, size_t count, loff_t *pos)
{
    const char *msg = "Hello from kernel!\n";
    size_t len = strlen(msg);
    if (*pos >= len)
        return 0; // EOF
    if (count > len - *pos)
        count = len - *pos;
    if (copy_to_user(buf, msg + *pos, count))
        return -EFAULT;
    *pos += count;
    return count;
}
```

**æ³¨æ„äº‹é¡¹ï¼š**

- ä¸èƒ½åœ¨ä¸­æ–­ä¸Šä¸‹æ–‡ã€åŸå­ä¸Šä¸‹æ–‡ï¼ˆå¦‚ spinlock ä¿æŠ¤åŒºåŸŸï¼‰ä¸­ä½¿ç”¨ï¼Œå› ä¸ºå¯èƒ½å¼•èµ·ç¡çœ ï¼ˆé¡µé”™è¯¯å¤„ç†å¯èƒ½å¯¼è‡´è°ƒåº¦ï¼‰ã€‚

- éªŒè¯ç”¨æˆ·æŒ‡é’ˆï¼Œå¯ä½¿ç”¨ `access_ok()` æå‰æ£€æŸ¥ç”¨æˆ·åœ°å€æ˜¯å¦å¯è®¿é—®ï¼ˆè™½ç„¶ `copy_to/from_user` å†…éƒ¨ä¹Ÿä¼šæ£€æŸ¥ï¼‰

  ```c
  if (!access_ok(VERIFY_READ, user_ptr, size))
      return -EFAULT;
  ```

- è¿™äº›å‡½æ•°æ¶‰åŠåœ°å€éªŒè¯å’Œé¡µè¡¨æ£€æŸ¥ï¼Œæ¯” `memcpy` æ…¢ï¼Œåº”é¿å…åœ¨æ€§èƒ½å…³é”®è·¯å¾„ä¸­é¢‘ç¹è°ƒç”¨ã€‚

- æ°¸è¿œä¸è¦å¿½ç•¥è¿”å›å€¼ï¼å¦åˆ™å¯èƒ½å¯¼è‡´å†…æ ¸ä½¿ç”¨æœªåˆå§‹åŒ–æˆ–é”™è¯¯çš„æ•°æ®ã€‚



#### **`ioctl`**






#### **`mmap`**

ï¼ˆMemory Mapï¼‰æ˜¯ä¸€ç§å°†æ–‡ä»¶æˆ–å…¶ä»–å¯¹è±¡æ˜ å°„åˆ°è¿›ç¨‹åœ°å€ç©ºé—´çš„å†…å­˜æ˜ å°„æœºåˆ¶ï¼Œå®ƒå…è®¸è¿›ç¨‹åƒè®¿é—®å†…å­˜ä¸€æ ·ç›´æ¥è®¿é—®æ–‡ä»¶å†…å®¹ã€‚

```c
#include <sys/mman.h>

//addr: å»ºè®®çš„æ˜ å°„èµ·å§‹åœ°å€ï¼ˆé€šå¸¸è®¾ä¸ºNULLï¼Œç”±å†…æ ¸å†³å®šï¼‰
//length: æ˜ å°„åŒºåŸŸçš„é•¿åº¦
//prot: ä¿æŠ¤æ ‡å¿—
//    PROT_READ: å¯è¯»
//    PROT_WRITE: å¯å†™
//    PROT_EXEC: å¯æ‰§è¡Œ
//    PROT_NONE: ä¸å¯è®¿é—®
//flags: æ˜ å°„ç±»å‹å’Œé€‰é¡¹
//    MAP_SHARED: å…±äº«æ˜ å°„ï¼ˆä¿®æ”¹ä¼šå†™å›æ–‡ä»¶ï¼‰
//    MAP_PRIVATE: ç§æœ‰æ˜ å°„ï¼ˆå†™æ—¶å¤åˆ¶ï¼‰
//    MAP_FIXED: ä½¿ç”¨æŒ‡å®šåœ°å€
//    MAP_ANONYMOUS: åŒ¿åæ˜ å°„ï¼ˆä¸ä¸æ–‡ä»¶å…³è”ï¼‰
//fd: æ–‡ä»¶æè¿°ç¬¦
//offset: æ–‡ä»¶åç§»é‡
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
```

å­—ç¬¦è®¾å¤‡é©±åŠ¨ç¤ºä¾‹

```c
// å­—ç¬¦è®¾å¤‡é©±åŠ¨ä¸­çš„mmapå®ç°
static int simple_mmap(struct file *filp, struct vm_area_struct *vma)
{
    struct simple_dev *dev = filp->private_data;
    unsigned long size = vma->vm_end - vma->vm_start;
    unsigned long pfn;
    // æ£€æŸ¥æ˜ å°„å¤§å°
    if (size > dev->buffer_size)
        return -EINVAL;
    // å°†ç‰©ç†åœ°å€è½¬æ¢ä¸ºé¡µå¸§å·
    pfn = virt_to_phys(dev->buffer) >> PAGE_SHIFT;
    // å»ºç«‹æ˜ å°„
    if (remap_pfn_range(vma, vma->vm_start, pfn, size, vma->vm_page_prot))
        return -EAGAIN;
    // è®¾ç½®VMAæ“ä½œ
    vma->vm_ops = &simple_vm_ops;
    vma->vm_private_data = dev;
    return 0;
}
static const struct vm_operations_struct simple_vm_ops = {
    .open = simple_vma_open,
    .close = simple_vma_close,
    .fault = simple_vma_fault,
};
```

é›¶æ‹·è´ç¤ºä¾‹

```c
// ä½¿ç”¨mmapå®ç°é›¶æ‹·è´æ–‡ä»¶å‘é€
void send_file_mmap(int sockfd, const char *filename)
{
    int fd = open(filename, O_RDONLY);
    struct stat st;
    fstat(fd, &st);
    void *map = mmap(NULL, st.st_size, PROT_READ,
                     MAP_PRIVATE, fd, 0);
    
    // ç›´æ¥ä½¿ç”¨sendfileæˆ–writevå‘é€æ˜ å°„çš„å†…å­˜
    write(sockfd, map, st.st_size);
    munmap(map, st.st_size);
    close(fd);
}
```

ä¼˜ç‚¹ï¼š

> 1. **å‡å°‘æ•°æ®æ‹·è´**ï¼šé¿å…ç”¨æˆ·ç©ºé—´å’Œå†…æ ¸ç©ºé—´ä¹‹é—´çš„æ‹·è´
> 2. **éšæœºè®¿é—®**ï¼šå¯ä»¥ç›´æ¥æŒ‡é’ˆè®¿é—®ï¼Œä¸éœ€è¦lseek
> 3. **å†…å­˜å…±äº«**ï¼šå¤šä¸ªè¿›ç¨‹å¯ä»¥å…±äº«åŒä¸€æ˜ å°„
> 4. **å»¶è¿ŸåŠ è½½**ï¼šæŒ‰éœ€åˆ†é¡µï¼Œå‡å°‘å†…å­˜å ç”¨

ç¼ºç‚¹ï¼š

> 1. **å†…å­˜ç¢ç‰‡**ï¼šå¯èƒ½å¯¼è‡´åœ°å€ç©ºé—´ç¢ç‰‡åŒ–
> 2. **æ˜ å°„å¼€é”€**ï¼šå°æ–‡ä»¶æ˜ å°„å¯èƒ½ä¸åˆ’ç®—
> 3. **åŒæ­¥é—®é¢˜**ï¼šéœ€è¦å¤„ç†ç¼“å­˜ä¸€è‡´æ€§
> 4. **é”™è¯¯å¤„ç†**ï¼šç¼ºé¡µå¼‚å¸¸å¯èƒ½å¯¼è‡´æ€§èƒ½æŠ–åŠ¨



#### **`kmalloc`**



#### **`kfree`**



#### **`kzalloc`**



#### **`devm_kmalloc`**



#### **`devm_kfree`**




### å‘½ä»¤

æŸ¥æ‰¾æ–‡æœ¬æ‰€åœ¨æ–‡ä»¶

#### **`grep`**

```bash
grep -nir "gpio0 13" rk3399*
```





## å…­ã€åŸºç¡€è®°å¿†ç‚¹

### å‘½ä»¤æ‰§è¡Œç¯å¢ƒ

`./test.sh`ï¼šåœ¨å­è¿›ç¨‹ç¯å¢ƒæ‰§è¡Œè„šæœ¬å†…å®¹

`. test.sh`ï¼šåœ¨å½“å‰è¿›ç¨‹æ‰§è¡Œè„šæœ¬å†…å®¹ï¼Œç­‰æ•ˆäº`source test.sh`



### æ–‡ä»¶ç±»å‹

Linux ç³»ç»Ÿä¸­çš„æ–‡ä»¶ç±»å‹ä¸»è¦å¯ä»¥é€šè¿‡ `ls -l`å‘½ä»¤è¾“å‡ºä¸­æ¯è¡Œé¦–ä½çš„é‚£ä¸ªå­—ç¬¦æ¥è¯†åˆ«ã€‚ä¸»è¦æœ‰ä»¥ä¸‹ 7 ç§åŸºæœ¬ç±»å‹ï¼š

| ç±»å‹             | æ ‡è¯†ç¬¦å· | æè¿°                                            | å¸¸è§ç¤ºä¾‹                   |
| ---------------- | -------- | ----------------------------------------------- | -------------------------- |
| **æ™®é€šæ–‡ä»¶**     | `-`      | æœ€å¸¸è§çš„ç±»å‹ï¼ŒåŒ…æ‹¬æ–‡æœ¬ã€äºŒè¿›åˆ¶ç¨‹åºã€å›¾ç‰‡ç­‰ã€‚    | `.txt`æ–‡æ¡£, `/bin/ls`å‘½ä»¤  |
| **ç›®å½•æ–‡ä»¶**     | `d`      | å³æ–‡ä»¶å¤¹ï¼Œç”¨äºç»„ç»‡æ–‡ä»¶å’Œå…¶ä»–ç›®å½•ã€‚              | `/home`, `/etc`            |
| **ç¬¦å·é“¾æ¥æ–‡ä»¶** | `l`      | ç±»ä¼¼ Windows çš„å¿«æ·æ–¹å¼ï¼ŒæŒ‡å‘å¦ä¸€ä¸ªæ–‡ä»¶æˆ–ç›®å½•ã€‚ | è½¯ä»¶ç‰ˆæœ¬å¿«æ·é“¾æ¥           |
| **å­—ç¬¦è®¾å¤‡æ–‡ä»¶** | `c`      | æä¾›æ— ç¼“å†²çš„é¡ºåºæ•°æ®æµè®¿é—®ï¼Œå¦‚é”®ç›˜ã€ç»ˆç«¯ã€‚      | `/dev/tty`(ç»ˆç«¯)           |
| **å—è®¾å¤‡æ–‡ä»¶**   | `b`      | æä¾›ç¼“å†²çš„éšæœºæ•°æ®å—è®¿é—®ï¼Œå¦‚ç¡¬ç›˜ã€Uç›˜ã€‚         | `/dev/sda`(ç¡¬ç›˜)           |
| **å¥—æ¥å­—æ–‡ä»¶**   | `s`      | ç”¨äºè¿›ç¨‹ä¹‹é—´çš„ç½‘ç»œé€šä¿¡æˆ–æœ¬åœ°è¿›ç¨‹é—´é€šä¿¡ã€‚        | `/var/run`ç›®å½•ä¸‹çš„æŸäº›æ–‡ä»¶ |
| **ç®¡é“æ–‡ä»¶**     | `p`      | ä¹Ÿç§°ä¸º FIFOï¼Œç”¨äºè¿›ç¨‹é—´çš„å•å‘æ•°æ®æµåŠ¨ã€‚         | ç”± `mkfifo`å‘½ä»¤åˆ›å»º        |



### å­—ç¬¦è®¾å¤‡å¼€å‘

é©±åŠ¨å¼€å‘ä¸»è¦æ˜¯å­—ç¬¦è®¾å¤‡å¼€å‘

![](img\015.png)



### è®¾å¤‡å·

å¦‚æœè¦è‡ªå®šä¹‰è®¾å¤‡å·ï¼Œåœ¨åˆ›å»ºçš„æ—¶å€™ç›´æ¥ä¼ å…¥>0çš„æ•°å€¼ï¼Œ0è¡¨ç¤ºç³»ç»Ÿç”Ÿæˆä¸»è®¾å¤‡å·

```c
register_chrdev(111, "hello_drv", &fops);
```

åœ¨ä»£ç ä¸­é€šå¸¸ä½¿ç”¨`MKDEV`å®æ¥æ„é€ å­—ç¬¦è®¾å¤‡æ–‡ä»¶çš„è¯†åˆ«å·

```c
// ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯æ³¨å†Œçš„ä¸»è®¾å¤‡å·ï¼Œç¬¬äºŒä¸ªæ˜¯è‡ªå®šä¹‰çš„æ¬¡è®¾å¤‡å·
// å®å®šä¹‰é‡Œé¢æ˜¯ä¸€ä¸ªå°†ä¸»è®¾å¤‡å·å·¦ç§»20ä½å†æ‹¼æ¥ä¸Šæ¬¡è®¾å¤‡å·çš„è¿ç®—
MKDEV(major, 0)
```



- æŸ¥çœ‹å†…æ ¸ä¸­å·²ç»ç”³è¯·çš„è®¾å¤‡å·

```bash
cat /proc/devices
```



- ç”¨æˆ·æ€åˆ›å»ºè®¾å¤‡æ–‡ä»¶

```bash
# mknod è®¾å¤‡æ–‡ä»¶è·¯å¾„ c|b ä¸»è®¾å¤‡å· æ¬¡è®¾å¤‡å·
mknod /dev/hello1 c 250 0
```



### ç»“æ„ä½“`file_operations`



### å†…è”å‡½æ•°`inline`

ä½¿ç”¨`inline`å…³é”®å­—å»ºè®®ç¼–è¯‘å™¨å°†å‡½æ•°è°ƒç”¨æ“ä½œæ›¿æ¢ä¸ºå‡½æ•°ä½“æœ¬èº«çš„ä»£ç ï¼Œè¿™ç±»ä¼¼äºä¸€ç§é«˜çº§çš„å¤åˆ¶ç²˜è´´ã€‚å®ƒçš„ä¸»è¦ç›®çš„æ˜¯**æ¶ˆé™¤å‡½æ•°è°ƒç”¨çš„å¼€é”€**ï¼Œä¾‹å¦‚å‚æ•°å‹æ ˆã€è·³è½¬å’Œè¿”å›æ“ä½œï¼Œè¿™å¯¹äºå°å‹ä¸”é¢‘ç¹è°ƒç”¨çš„å‡½æ•°èƒ½æå‡æ•ˆç‡

ä½†éœ€è¦æ³¨æ„ï¼Œ`inline`ä»…ä»…æ˜¯**ç»™ç¼–è¯‘å™¨çš„ä¸€ä¸ªå»ºè®®**ã€‚ç¼–è¯‘å™¨ä¼šæ ¹æ®ä¼˜åŒ–ç­–ç•¥ã€å‡½æ•°å¤æ‚åº¦å’Œå¤§å°ç­‰å› ç´ å†³å®šæ˜¯å¦çœŸæ­£å†…è”ã€‚ä¾‹å¦‚ï¼ŒåŒ…å«å¾ªç¯æˆ–é€’å½’è°ƒç”¨çš„å¤æ‚å‡½æ•°ï¼Œæˆ–è€…å‡½æ•°ä½“è¿‡å¤§æ—¶ï¼Œç¼–è¯‘å™¨å¾ˆå¯èƒ½å¿½ç•¥å†…è”å»ºè®®

å†…è”å‡½æ•°å¸¸å¸¸è¢«æ‹¿æ¥ä¸å®ï¼ˆ`#define`ï¼‰æ¯”è¾ƒï¼Œå› ä¸ºå®ƒä»¬éƒ½èƒ½åœ¨ç¼–è¯‘å‰è¿›è¡Œä»£ç å±•å¼€ã€‚ä½†å®ƒä»¬åœ¨æœ¬è´¨ä¸Šæœ‰æ˜¾è‘—åŒºåˆ«ï¼Œå…·ä½“å¦‚ä¸‹è¡¨æ‰€ç¤ºï¼š

| ç‰¹æ€§ | å†…è”å‡½æ•° (`inline`) | å®å®šä¹‰ (`#define`) |
| :--- | :--- | :--- |
| **å¤„ç†é˜¶æ®µ** | **ç¼–è¯‘æ—¶**å±•å¼€ï¼Œæ˜¯ç¼–è¯‘å™¨è¡Œä¸º | **é¢„ç¼–è¯‘æ—¶**è¿›è¡Œæ–‡æœ¬æ›¿æ¢ï¼Œæ˜¯é¢„å¤„ç†å™¨è¡Œä¸º |
| **ç±»å‹æ£€æŸ¥** | **æ‰§è¡Œä¸¥æ ¼çš„ç±»å‹æ£€æŸ¥**ï¼Œå®‰å…¨æ€§é«˜ | **ä¸åšä»»ä½•ç±»å‹æ£€æŸ¥**ï¼Œç›´æ¥æ›¿æ¢æ–‡æœ¬ï¼Œå®¹æ˜“å› å‚æ•°ç±»å‹æˆ–è¡¨è¾¾å¼å¤æ‚æ€§å¯¼è‡´æ„æƒ³ä¸åˆ°çš„é”™è¯¯ |
| **è°ƒè¯•æ”¯æŒ** | æ”¯æŒç¬¦å·è°ƒè¯•ï¼Œè°ƒè¯•ä¿¡æ¯æ›´å‹å¥½ | è°ƒè¯•å›°éš¾ï¼Œå› ä¸ºè°ƒè¯•å™¨çœ‹åˆ°çš„æ˜¯æ›¿æ¢åçš„ä»£ç ï¼Œè€Œéå®åæœ¬èº« |
| **å‰¯ä½œç”¨é£é™©** | æ— å‰¯ä½œç”¨ï¼Œå‚æ•°åªè®¡ç®—ä¸€æ¬¡ | å‚æ•°å¯èƒ½è¢«å¤šæ¬¡æ±‚å€¼ï¼Œå®¹æ˜“äº§ç”Ÿå‰¯ä½œç”¨ï¼Œä¾‹å¦‚ `#define SQUARE(x) ((x)*(x))`ï¼Œè‹¥å‚æ•°ä¸º`a++`ï¼Œåˆ™`a`ä¼šè¢«é€’å¢ä¸¤æ¬¡ |

ç¤ºä¾‹

```c
static inline int register_chrdev(unsigned int major, const char *name, const struct file_operations *fops)
{
	return __register_chrdev(major, 0, 256, name, fops);
}
```



### **`file`ç»“æ„ä½“ä¼ é€’æ•°æ®**

ç¤ºä¾‹

```c
//å®šä¹‰writeå‡½æ•°
static ssize_t led_write(struct file *filp, const char __user *user_buf, size_t c, loff_t *lof)
{
	/* å¯ä»¥ä»struct fileä¸­è·å–ç”¨æˆ·æ€ä¸åŒè¿›ç¨‹ä¸­çš„ */
	return 0;
}
```

å¯ä»¥ä»ç”¨æˆ·æ€æºå¸¦æ•°æ®

```c
struct file {
//....
	/* needed for tty driver, and maybe others */
	void			*private_data;   
//....
} 

```



### **`container_of`**





## ä¸ƒã€å¯„å­˜å™¨å¼€å‘



**`ioremap`**ï¼šç‰©ç†åœ°å€æ˜ å°„









## å…«ã€GPIOå­ç³»ç»Ÿ

è‡ª Linux å†…æ ¸ 4.8 èµ·ï¼ŒGPIO å­ç³»ç»Ÿè¿›è¡Œäº†ç°ä»£åŒ–é‡æ„ï¼Œå¼•å…¥äº† **gpiodï¼ˆGPIO descriptorï¼‰** æ¥å£ï¼Œå–ä»£äº†æ—©æœŸåŸºäºæ•´æ•° GPIO ç¼–å·ï¼ˆgpio numberï¼‰çš„æ—§æ¥å£

- **åŸºäºæè¿°ç¬¦çš„API** (æ¨è)ï¼š`include/linux/gpio/consumer.h`
- **ä¼ ç»Ÿæ•´æ•°API** (é€æ¸æ·˜æ±°)ï¼š`include/linux/gpio.h`

**æ³¨æ„**ï¼šgpioå­ç³»ç»Ÿåªèƒ½è§£å†³è¾“å‡ºè¾“å…¥ç®€å•æ§åˆ¶ï¼Œæ§åˆ¶å¯„å­˜å™¨å¤ç”¨ç‰‡ä¸Šå¤–è®¾çº§åˆ«éœ€è¦pinctlå­ç³»ç»Ÿæ“ä½œ



### 1.åŸºäºæè¿°ç¬¦çš„API

#### è·å–GPIOå¥æŸ„

```c
#include <linux/gpio/consumer.h>

/**
 * @brief è·å–å•ä¸ªGPIOæè¿°ç¬¦
 * @param dev: ä½¿ç”¨è¯¥GPIOçš„è®¾å¤‡æŒ‡é’ˆï¼ˆé€šå¸¸ä¸º&pdev->devï¼‰
 * @param con_id: GPIOåœ¨è®¾å¤‡æ ‘ä¸­çš„åç§°æ ‡è¯†ç¬¦ï¼ˆå¦‚"enable"ã€"reset"ï¼‰
 * @param flags: GPIOé…ç½®æ ‡å¿—ï¼ŒæŒ‡å®šæ–¹å‘å’Œåˆå§‹çŠ¶æ€
 * @return æˆåŠŸè¿”å›GPIOæè¿°ç¬¦æŒ‡é’ˆï¼Œå¤±è´¥è¿”å›ERR_PTRé”™è¯¯ç 
 * 
 * ç¤ºä¾‹ï¼šè·å–è®¾å¤‡æ ‘ä¸­åä¸º"enable"çš„GPIO
 * struct gpio_desc *en = gpiod_get(&pdev->dev, "enable", GPIOD_OUT_LOW);
 */
struct gpio_desc *gpiod_get(struct device *dev, const char *con_id, enum gpiod_flags flags);

/**
 * @brief è·å–ç´¢å¼•GPIOæè¿°ç¬¦ï¼ˆç”¨äºåŒåç§°å¤šä¸ªGPIOçš„æƒ…å†µï¼‰
 * @param dev: ä½¿ç”¨è¯¥GPIOçš„è®¾å¤‡æŒ‡é’ˆ
 * @param con_id: GPIOåœ¨è®¾å¤‡æ ‘ä¸­çš„åç§°æ ‡è¯†ç¬¦
 * @param index: GPIOç´¢å¼•å·ï¼ˆä»0å¼€å§‹ï¼‰
 * @param flags: GPIOé…ç½®æ ‡å¿—
 * @return æˆåŠŸè¿”å›GPIOæè¿°ç¬¦æŒ‡é’ˆï¼Œå¤±è´¥è¿”å›ERR_PTRé”™è¯¯ç 
 * 
 * ç¤ºä¾‹ï¼šè®¾å¤‡æ ‘ä¸­æœ‰`cs-gpios = <&gpio1 0>, <&gpio1 1>, <&gpio1 2>;`
 * è·å–ç¬¬äºŒä¸ªç‰‡é€‰ï¼šgpiod_get_index(dev, "cs", 1, GPIOD_OUT_HIGH);
 */
struct gpio_desc *gpiod_get_index(struct device *dev, const char *con_id, unsigned int index, enum gpiod_flags flags);

/**
 * @brief è®¾å¤‡ç®¡ç†ç‰ˆæœ¬çš„GPIOè·å–å‡½æ•°ï¼ˆè‡ªåŠ¨é‡Šæ”¾ï¼‰
 * @param dev: ä½¿ç”¨è¯¥GPIOçš„è®¾å¤‡æŒ‡é’ˆ
 * @param con_id: GPIOåœ¨è®¾å¤‡æ ‘ä¸­çš„åç§°æ ‡è¯†ç¬¦
 * @param flags: GPIOé…ç½®æ ‡å¿—
 * @return æˆåŠŸè¿”å›GPIOæè¿°ç¬¦æŒ‡é’ˆï¼Œå¤±è´¥è¿”å›ERR_PTRé”™è¯¯ç 
 * 
 * æ³¨æ„ï¼šä½¿ç”¨æ­¤å‡½æ•°è·å–çš„GPIOä¼šåœ¨è®¾å¤‡é‡Šæ”¾æ—¶è‡ªåŠ¨è°ƒç”¨gpiod_put()
 * æ— éœ€åœ¨removeå‡½æ•°ä¸­æ‰‹åŠ¨é‡Šæ”¾ï¼Œé¿å…èµ„æºæ³„æ¼
 */
struct gpio_desc *devm_gpiod_get(struct device *dev, const char *con_id, enum gpiod_flags flags);
```

**å¸¸ç”¨flagsï¼š**

- `GPIOD_IN` - è¾“å…¥æ–¹å‘
- `GPIOD_OUT_LOW` - è¾“å‡ºæ–¹å‘ï¼Œåˆå§‹ä½ç”µå¹³
- `GPIOD_OUT_HIGH` - è¾“å‡ºæ–¹å‘ï¼Œåˆå§‹é«˜ç”µå¹³
- `GPIOD_ASIS` - ä¸æ”¹å˜å½“å‰æ–¹å‘

#### é…ç½®GPIO

```c
/**
 * @brief è®¾ç½®GPIOä¸ºè¾“å…¥æ–¹å‘
 * @param desc: GPIOæè¿°ç¬¦æŒ‡é’ˆï¼ˆç”±gpiod_getç­‰å‡½æ•°è·å–ï¼‰
 * @return æˆåŠŸè¿”å›0ï¼Œå¤±è´¥è¿”å›è´Ÿçš„é”™è¯¯ç 
 * 
 * é”™è¯¯ç ï¼š
 * -EINVAL: GPIOæè¿°ç¬¦æ— æ•ˆ
 * -ENOTSUPP: GPIOä¸æ”¯æŒè¾“å…¥æ–¹å‘
 * å…¶ä»–: ç¡¬ä»¶ç›¸å…³çš„é”™è¯¯
 */
int gpiod_direction_input(struct gpio_desc *desc);
/**
 * @brief è®¾ç½®GPIOä¸ºè¾“å‡ºæ–¹å‘å¹¶æŒ‡å®šåˆå§‹å€¼
 * @param desc: GPIOæè¿°ç¬¦æŒ‡é’ˆ
 * @param value: åˆå§‹è¾“å‡ºå€¼
 *              - 0: è¾“å‡ºä½ç”µå¹³
 *              - 1: è¾“å‡ºé«˜ç”µå¹³
 * @return æˆåŠŸè¿”å›0ï¼Œå¤±è´¥è¿”å›è´Ÿçš„é”™è¯¯ç 
 */
int gpiod_direction_output(struct gpio_desc *desc, int value);

/**
 * @brief è¯»å–GPIOå½“å‰å€¼ï¼ˆåŸå­ä¸Šä¸‹æ–‡ä½¿ç”¨ï¼‰
 * @param desc: GPIOæè¿°ç¬¦æŒ‡é’ˆ
 * @return GPIOçš„é€»è¾‘å€¼ï¼ˆå·²è€ƒè™‘active-lowï¼‰ï¼š
 *         - 0: ä½ç”µå¹³
 *         - 1: é«˜ç”µå¹³
 * 
 * æ³¨æ„ï¼šæ­¤å‡½æ•°å¯ä»¥åœ¨ä¸­æ–­ä¸Šä¸‹æ–‡ç­‰åŸå­ä¸Šä¸‹æ–‡ä¸­ä½¿ç”¨
 * ä½†ä¸èƒ½ç”¨äºå¯èƒ½å¯¼è‡´ä¼‘çœ çš„GPIOæ§åˆ¶å™¨ï¼ˆå¦‚I2C GPIOæ‰©å±•å™¨ï¼‰
 */
int gpiod_get_value(const struct gpio_desc *desc);

/**
 * @brief è®¾ç½®GPIOè¾“å‡ºå€¼ï¼ˆåŸå­ä¸Šä¸‹æ–‡ä½¿ç”¨ï¼‰
 * @param desc: GPIOæè¿°ç¬¦æŒ‡é’ˆ
 * @param value: è¦è®¾ç½®çš„å€¼
 *              - 0: è¾“å‡ºä½ç”µå¹³
 *              - 1: è¾“å‡ºé«˜ç”µå¹³
 */
void gpiod_set_value(struct gpio_desc *desc, int value);

// è®¾ç½®å¤šä¸ªGPIOå€¼
void gpiod_set_array_value(unsigned int array_size, struct gpio_desc **desc_array, int *value_array);


/**
 * @brief è¯»å–GPIOå½“å‰å€¼ï¼ˆå¯èƒ½ä¼‘çœ ç‰ˆæœ¬ï¼‰ï¼›è·å–å¸¦åç½®çš„GPIOå€¼ï¼ˆè€ƒè™‘äº†active_lowï¼‰
 * @param desc: GPIOæè¿°ç¬¦æŒ‡é’ˆ
 * @return GPIOçš„é€»è¾‘å€¼
 * 
 * é€‚ç”¨äºé€šè¿‡I2Cã€SPIç­‰æ€»çº¿è®¿é—®çš„GPIOæ§åˆ¶å™¨
 * è¿™äº›æ§åˆ¶å™¨çš„è®¿é—®å¯èƒ½å¼•èµ·ä¼‘çœ ï¼Œä¸èƒ½åœ¨åŸå­ä¸Šä¸‹æ–‡ä½¿ç”¨
 */
int gpiod_get_value_cansleep(const struct gpio_desc *desc);
/**
 * @brief è®¾ç½®GPIOè¾“å‡ºå€¼ï¼ˆå¯èƒ½ä¼‘çœ ç‰ˆæœ¬ï¼‰
 * @param desc: GPIOæè¿°ç¬¦æŒ‡é’ˆ
 * @param value: è¦è®¾ç½®çš„å€¼
 */
void gpiod_set_value_cansleep(struct gpio_desc *desc, int value);
```

#### GPIOä¸­æ–­

```c
/**
 * @brief å°†GPIOè½¬æ¢ä¸ºä¸­æ–­å·
 * @param desc: GPIOæè¿°ç¬¦æŒ‡é’ˆï¼ˆå¿…é¡»å·²é…ç½®ä¸ºè¾“å…¥ï¼‰
 * @return æˆåŠŸè¿”å›ä¸­æ–­å·ï¼Œå¤±è´¥è¿”å›è´Ÿçš„é”™è¯¯ç 
 * 
 * é”™è¯¯ç ï¼š
 * -ENXIO: GPIOä¸æ”¯æŒä¸­æ–­
 * -EINVAL: GPIOæè¿°ç¬¦æ— æ•ˆæˆ–æœªé…ç½®ä¸ºè¾“å…¥
 * 
 * ç¤ºä¾‹ï¼š
 * int irq = gpiod_to_irq(button_gpio);
 * request_irq(irq, handler, IRQF_TRIGGER_RISING, "button", dev);
 */
int gpiod_to_irq(const struct gpio_desc *desc);

// è®¾ç½®ä¸­æ–­è§¦å‘ç±»å‹ï¼ˆé€šå¸¸åœ¨request_irqä¸­ä½¿ç”¨ï¼‰
irqreturn_t gpio_irq_handler(int irq, void *data);
```

#### é‡Šæ”¾GPIO

```c
void gpiod_put(struct gpio_desc *desc);
void devm_gpiod_put(struct device *dev, struct gpio_desc *desc);
```





### 2.ä¼ ç»Ÿæ•´æ•°API



#### GPIOç¼–å·ç®¡ç†

```c
#include <linux/gpio.h>

// GPIOå·ä¸æè¿°ç¬¦è½¬æ¢
int desc_to_gpio(const struct gpio_desc *desc);
struct gpio_desc *gpio_to_desc(unsigned gpio);

// GPIOå·æœ‰æ•ˆæ€§æ£€æŸ¥
bool gpio_is_valid(int gpio);
```



#### ç”³è¯·å’Œé‡Šæ”¾

```c
// ç”³è¯·GPIO
int gpio_request(unsigned gpio, const char *label);

// é…ç½®æ–¹å‘
int gpio_direction_input(unsigned gpio);
int gpio_direction_output(unsigned gpio, int value);

// è¯»å†™å€¼
int gpio_get_value(unsigned gpio);
void gpio_set_value(unsigned gpio, int value);

// é‡Šæ”¾GPIO
void gpio_free(unsigned gpio);
```

ç®€å•ç¤ºä¾‹

```c
//åˆå§‹åŒ–ç¡¬ä»¶
led_device->gpio_led = 55; //GPIO1_C7
//ç”³è¯·å¼•è„š
ret = gpio_request(led_device->gpio_led, "led2_green");
if (ret) {
    printk("gpio_request fail\n");
    goto err_gpio_request;
}
//è®¾ç½®å¼•è„šä¸ºè¾“å‡ºåŠŸèƒ½
gpio_direction_output(led_device->gpio_led, 0); //é»˜è®¤led off
//é‡Šæ”¾å¼•è„š
gpio_free(led_device->gpio_led);
```





### 3.è®¾å¤‡æ ‘ç¤ºä¾‹

```c
// ç¤ºä¾‹ï¼šLEDæ§åˆ¶
leds {
    compatible = "gpio-leds";
    led1 {
        label = "system:red:status";
        gpios = <&gpio0 12 GPIO_ACTIVE_HIGH>;
        linux,default-trigger = "heartbeat";
        default-state = "off";
    };
};

// ç¤ºä¾‹ï¼šæŒ‰é’®è¾“å…¥
buttons {
    compatible = "gpio-keys";
    button1 {
        label = "Power Button";
        gpios = <&gpio0 13 GPIO_ACTIVE_LOW>;
        linux,code = <KEY_POWER>;
    };
};

// è‡ªå®šä¹‰è®¾å¤‡
my_device {
    compatible = "my-company,my-device";
    enable-gpios = <&gpio1 5 GPIO_ACTIVE_HIGH>;
    reset-gpios = <&gpio1 6 GPIO_ACTIVE_LOW>;
    interrupt-parent = <&gpio0>;
    interrupts = <14 IRQ_TYPE_EDGE_RISING>;
};
```



### 4.é©±åŠ¨ä»£ç ç¤ºä¾‹

```c
#include <linux/module.h>
#include <linux/platform_device.h>
#include <linux/gpio/consumer.h>

struct my_device {
    struct gpio_desc *enable_gpio;
    struct gpio_desc *reset_gpio;
    int irq;
};

static irqreturn_t my_interrupt_handler(int irq, void *dev_id)
{
    struct my_device *dev = dev_id;
    int value = gpiod_get_value(dev->reset_gpio);
    
    printk(KERN_INFO "GPIO interrupt triggered, value: %d\n", value);
    return IRQ_HANDLED;
}

static int my_probe(struct platform_device *pdev)
{
    struct device *dev = &pdev->dev;
    struct my_device *my_dev;
    int ret;
    
    // åˆ†é…è®¾å¤‡ç»“æ„
    my_dev = devm_kzalloc(dev, sizeof(*my_dev), GFP_KERNEL);
    if (!my_dev)
        return -ENOMEM;
    
    // è·å–GPIOæè¿°ç¬¦
    my_dev->enable_gpio = devm_gpiod_get(dev, "enable", GPIOD_OUT_LOW);
    if (IS_ERR(my_dev->enable_gpio))
        return dev_err_probe(dev, PTR_ERR(my_dev->enable_gpio),
                           "failed to get enable GPIO\n");
    
    my_dev->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_IN);
    if (IS_ERR(my_dev->reset_gpio))
        return dev_err_probe(dev, PTR_ERR(my_dev->reset_gpio),
                           "failed to get reset GPIO\n");
    
    // æ§åˆ¶GPIO
    gpiod_set_value(my_dev->enable_gpio, 1);
    mdelay(10);
    
    // é…ç½®ä¸ºä¸­æ–­
    my_dev->irq = gpiod_to_irq(my_dev->reset_gpio);
    ret = devm_request_irq(dev, my_dev->irq, my_interrupt_handler,
                          IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
                          "my-device", my_dev);
    if (ret) {
        dev_err(dev, "failed to request IRQ: %d\n", ret);
        return ret;
    }
    
    // å­˜å‚¨è®¾å¤‡æ•°æ®
    platform_set_drvdata(pdev, my_dev);
    
    dev_info(dev, "device probed successfully\n");
    return 0;
}

static int my_remove(struct platform_device *pdev)
{
    struct my_device *my_dev = platform_get_drvdata(pdev);
    
    // å…³é—­è®¾å¤‡
    gpiod_set_value(my_dev->enable_gpio, 0);
    
    dev_info(&pdev->dev, "device removed\n");
    return 0;
}

static const struct of_device_id my_of_match[] = {
    { .compatible = "my-company,my-device" },
    {},
};
MODULE_DEVICE_TABLE(of, my_of_match);

static struct platform_driver my_driver = {
    .driver = {
        .name = "my-device",
        .of_match_table = my_of_match,
    },
    .probe = my_probe,
    .remove = my_remove,
};
module_platform_driver(my_driver);
```



### 5.å¸¸ç”¨è°ƒè¯•å‘½ä»¤

```bash
# æŸ¥çœ‹GPIOä½¿ç”¨æƒ…å†µ
$ cat /sys/kernel/debug/gpio

# GPIO sysfsæ¥å£ï¼ˆå¦‚æœé…ç½®äº†CONFIG_GPIO_SYSFSï¼‰
$ ls /sys/class/gpio/
export  gpiochip0  gpiochip32  unexport

# å¯¼å‡ºGPIOè¿›è¡Œæ‰‹åŠ¨æ§åˆ¶
$ echo 12 > /sys/class/gpio/export
$ echo out > /sys/class/gpio/gpio12/direction
$ echo 1 > /sys/class/gpio/gpio12/value
```



### 6.å†…æ ¸é…ç½®é€‰é¡¹

```bash
# å†…æ ¸é…ç½®é€‰é¡¹
CONFIG_GPIOLIB=y           # å¯ç”¨GPIOåº“æ”¯æŒ
CONFIG_GPIO_SYSFS=y        # å¯ç”¨sysfsæ¥å£ï¼ˆè°ƒè¯•ç”¨ï¼‰
CONFIG_GPIO_CDEV=y         # å¯ç”¨å­—ç¬¦è®¾å¤‡æ¥å£ï¼ˆæ¨èï¼‰
CONFIG_GPIO_DEBUGFS=y      # å¯ç”¨debugfsæ¥å£
```



## ä¹ã€ä¸­æ–­å­ç³»ç»Ÿ

1. **ç¡¬ä»¶è§¦å‘ä¸­æ–­**ï¼ˆå¦‚ GPIOã€UARTã€Timer ç­‰ï¼‰ã€‚
2. **CPU è·³è½¬åˆ°å†…æ ¸çš„ä¸­æ–­å…¥å£**ã€‚
3. **é€šç”¨ IRQ å±‚è°ƒç”¨æ³¨å†Œçš„ä¸­æ–­å¤„ç†å‡½æ•°ï¼ˆhandlerï¼‰**ã€‚
4. **é©±åŠ¨åœ¨ä¸­æ–­ä¸Šä¸‹æ–‡ä¸­æ‰§è¡Œå…³é”®ã€å¿«é€Ÿçš„æ“ä½œï¼ˆä¸ŠåŠéƒ¨ï¼‰**ã€‚
5. **å¦‚æœ‰è€—æ—¶å·¥ä½œï¼Œæäº¤åˆ°ä¸‹åŠéƒ¨ï¼ˆå¦‚ workqueueã€taskletã€softirqï¼‰å¤„ç†**ã€‚



### 1.ä¸­æ–­æ³¨å†Œä¸é‡Šæ”¾å‡½æ•°

æŸ¥çœ‹å·²æ³¨å†Œä¸­æ–­å·ï¼š`cat /proc/interrupts`

#### **`request_irq`**

æ³¨å†Œä¸­æ–­å¤„ç†å‡½æ•°ï¼ˆæœ€å¸¸ç”¨ï¼‰

```c
/*
 * irqï¼šä¸­æ–­å·ï¼ˆå¯ä» GPIOã€è®¾å¤‡æ ‘ç­‰è·å–ï¼‰ã€‚
 * handlerï¼šä¸­æ–­å¤„ç†å‡½æ•°ï¼ŒåŸå‹ä¸ºï¼širqreturn_t handler(int irq, void *dev_id);
 * flagsï¼šä¸­æ–­æ ‡å¿—ï¼ˆè§ä¸‹è¡¨ï¼‰ã€‚
 * nameï¼šä¸­æ–­åç§°ï¼ˆ/proc/interrupts ä¸­å¯è§ï¼‰ã€‚
 * devï¼šè®¾å¤‡ç§æœ‰æ•°æ®æŒ‡é’ˆï¼ˆç”¨äºå…±äº«ä¸­æ–­æ—¶åŒºåˆ†è®¾å¤‡ï¼‰ã€‚
 */
int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev);
/* è¿”å›å€¼ï¼š0 æˆåŠŸï¼Œè´Ÿå€¼è¡¨ç¤ºé”™è¯¯ï¼ˆå¦‚ -EBUSY è¡¨ç¤º IRQ è¢«å ç”¨ä¸”æœªå…±äº«ï¼‰ã€‚ */
```

å¸¸ç”¨ flagsï¼š

| `IRQF_SHARED`          | å…±äº«ä¸­æ–­çº¿ï¼ˆå¤šä¸ªè®¾å¤‡å…±ç”¨åŒä¸€ IRQï¼‰ |
| ---------------------- | ---------------------------------- |
| `IRQF_TRIGGER_RISING`  | ä¸Šå‡æ²¿è§¦å‘ï¼ˆå¸¸ç”¨äº GPIOï¼‰          |
| `IRQF_TRIGGER_FALLING` | ä¸‹é™æ²¿è§¦å‘                         |
| `IRQF_TRIGGER_HIGH`    | é«˜ç”µå¹³è§¦å‘                         |
| `IRQF_TRIGGER_LOW`     | ä½ç”µå¹³è§¦å‘                         |
| `IRQF_ONESHOT`         | çº¿ç¨‹åŒ–ä¸­æ–­ï¼ˆè§ä¸‹æ–‡ï¼‰               |



#### **`free_irq`**

é‡Šæ”¾ä¸­æ–­

```c
/*
 * å¿…é¡»ä½¿ç”¨ä¸ request_irq() ç›¸åŒçš„ irq å’Œ dev å‚æ•°ã€‚
 * è‹¥ä¸ºå…±äº«ä¸­æ–­ï¼Œä»…é‡Šæ”¾å½“å‰è®¾å¤‡çš„ handlerï¼›å½“æ‰€æœ‰ handler é‡Šæ”¾åï¼ŒIRQ æ‰çœŸæ­£é‡Šæ”¾ã€‚
 */
void free_irq(unsigned int irq, void *dev);
```



### 2.ä» GPIO è·å– IRQ å·



#### **`gpiod_to_irq`** 

```c
int irq = gpiod_to_irq(gpio_desc);
if (irq < 0) {
    dev_err(dev, "GPIO to IRQ failed\n");
    return irq;
}
```



#### **`gpio_to_irq`**

```c
/* è€ç‰ˆæœ¬gpioå­ç³»ç»Ÿçš„æ•´æ•°å¼•è„šå· */
int irq = gpio_to_irq(unsigned int gpio);
/* è¿”å›ä¸­æ–­å· */
```



### 3.è®¾å¤‡æ ‘ä¸­çš„ä¸­æ–­æè¿°

```dtd
my_device: my-device@0 {
    compatible = "example,mydev";
    interrupts = <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>;
    interrupt-parent = <&gic>;
};
```

ä»£ç ä¸­è·å–ä¸­æ–­å·

```c
/* platform_get_irq() è‡ªåŠ¨è§£æè®¾å¤‡æ ‘ interrupts å±æ€§ã€‚ */
int irq = platform_get_irq(pdev, 0); // è·å–ç¬¬ 0 ä¸ªä¸­æ–­
if (irq < 0)
    return irq;
```

å…¶ä»–å¸¸ç”¨å‡½æ•°

| å‡½æ•°                          | è¯´æ˜                                                |
| ----------------------------- | --------------------------------------------------- |
| `enable_irq(irq)`             | å¯ç”¨å·²æ³¨å†Œçš„ä¸­æ–­ï¼ˆé€šå¸¸ä¸ `disable_irq()` é…å¯¹ï¼‰     |
| `disable_irq(irq)`            | ç¦ç”¨ä¸­æ–­ï¼ˆä¼šç­‰å¾…å½“å‰ handler æ‰§è¡Œå®Œï¼Œ**å¯èƒ½ç¡çœ **ï¼‰ |
| `disable_irq_nosync(irq)`     | ç¦ç”¨ä¸­æ–­ä½†ä¸ç­‰å¾…ï¼ˆ**å¯åœ¨ä¸­æ–­ä¸Šä¸‹æ–‡è°ƒç”¨**ï¼‰          |
| `synchronize_irq(irq)`        | ç­‰å¾…è¯¥ IRQ æ‰€æœ‰ pending handler æ‰§è¡Œå®Œæ¯•            |
| `irq_set_irq_type(irq, type)` | åŠ¨æ€ä¿®æ”¹è§¦å‘ç±»å‹ï¼ˆå¦‚ä»ä¸Šå‡æ²¿æ”¹ä¸ºä¸‹é™æ²¿ï¼‰            |

> **æ³¨æ„**ï¼š`disable_irq()` ä¼šé˜»å¡ç›´åˆ°å½“å‰ä¸­æ–­å¤„ç†å®Œæˆï¼Œ**ä¸èƒ½åœ¨ä¸­æ–­ä¸Šä¸‹æ–‡è°ƒç”¨**ï¼›è‹¥éœ€åœ¨ä¸­æ–­ä¸­ç¦ç”¨è‡ªèº«ï¼Œåº”ä½¿ç”¨ `disable_irq_nosync()`ã€‚



### 4.ä¸­æ–­ä¸‹åŠéƒ¨

å†…æ ¸æœåŠ¡ï¼Œç›¸å½“äºå†…æ ¸çº¿ç¨‹

- `[ksoftirqd]`ï¼šå†…æ ¸å°ä»»åŠ¡
  - `ps -aux | grep ksoftirqd`

- `[kworker]`ï¼šå·¥ä½œé˜Ÿåˆ—ï¼Œè¿›ç¨‹ä¸Šä¸‹æ–‡
  - `ps -aux | grep kworker`


| ç‰¹æ€§           | `workqueue`                           | `tasklet`                           |
| -------------- | ------------------------------------- | ----------------------------------- |
| **æ‰§è¡Œä¸Šä¸‹æ–‡** | è¿›ç¨‹ä¸Šä¸‹æ–‡ï¼ˆå†…æ ¸çº¿ç¨‹ï¼‰                | è½¯ä¸­æ–­ä¸Šä¸‹æ–‡ï¼ˆä¸­æ–­ä¸Šä¸‹æ–‡ï¼‰          |
| **æ˜¯å¦å¯ç¡çœ ** | âœ… å¯ä»¥ï¼ˆ`GFP_KERNEL`ã€`msleep()` ç­‰ï¼‰ | âŒ ä¸å¯ç¡çœ                           |
| **æ‰§è¡Œæ—¶æœº**   | å¼‚æ­¥ï¼Œç”±å†…æ ¸çº¿ç¨‹è°ƒåº¦                  | ç´§æ¥åœ¨ç¡¬ä¸­æ–­ä¹‹åï¼ˆ`irq_exit()` æ—¶ï¼‰ |
| **èƒ½å¦è¢«æŠ¢å ** | âœ… å¯è¢«è°ƒåº¦å™¨æŠ¢å                       | âŒ ä¸å¯æŠ¢å ï¼ˆå…³ä¸­æ–­æ‰§è¡Œï¼‰            |
| **SMP æ”¯æŒ**   | âœ… å¯åœ¨ä»»æ„ CPU æ‰§è¡Œï¼ˆé»˜è®¤ï¼‰           | âœ… ä½†é»˜è®¤ç»‘å®šåˆ°è§¦å‘ä¸­æ–­çš„ CPU        |
| **é‡å¤è°ƒåº¦**   | å¯å¤šæ¬¡è°ƒåº¦ï¼ˆæ¯æ¬¡åˆ›å»ºæ–° workï¼‰         | åŒä¸€ tasklet åœ¨æ‰§è¡Œå‰ä¸ä¼šé‡å¤è¿è¡Œ   |
| **å»¶è¿Ÿæ•æ„Ÿæ€§** | è¾ƒä½ï¼ˆæœ‰è°ƒåº¦å»¶è¿Ÿï¼‰                    | è¾ƒé«˜ï¼ˆå»¶è¿Ÿå°ï¼‰                      |
| **æ¨èä½¿ç”¨**   | **ç°ä»£é©±åŠ¨é¦–é€‰**                      | ä»…ç”¨äºç®€å•ã€å¿«é€Ÿã€éé˜»å¡ä»»åŠ¡        |

> ğŸ“Œ **ç»“è®º**ï¼š**é™¤éæœ‰æä½å»¶è¿Ÿè¦æ±‚ï¼Œå¦åˆ™ä¼˜å…ˆä½¿ç”¨ `workqueue`**ã€‚`tasklet` å·²é€æ¸è¢«å¼ƒç”¨ï¼ˆå†…æ ¸ç¤¾åŒºå»ºè®®è¿ç§»åˆ° `workqueue` æˆ– `irq` çº¿ç¨‹ï¼‰ã€‚



####  `workqueue`åŸºæœ¬æ¦‚å¿µ

- `workqueue` æ˜¯ä¸€ä¸ª**å†…æ ¸çº¿ç¨‹æ± **ï¼Œç”¨äºå¼‚æ­¥æ‰§è¡Œâ€œå·¥ä½œé¡¹â€ï¼ˆ`struct work_struct`ï¼‰ã€‚
- å·¥ä½œé¡¹è¢«æäº¤åï¼Œç”±å†…æ ¸çº¿ç¨‹ï¼ˆå¦‚ `kworker/0:1`ï¼‰åœ¨**è¿›ç¨‹ä¸Šä¸‹æ–‡**ä¸­æ‰§è¡Œã€‚
- å¯ç¡çœ ã€å¯è°ƒåº¦ã€å¯ä½¿ç”¨ `mutex`ã€`wait_queue` ç­‰ã€‚

#### å¸¸ç”¨ API

æ–¹å¼ä¸€ï¼šé™æ€å®šä¹‰ï¼ˆæ¨èï¼‰

```c
#include <linux/workqueue.h>

void my_work_handler(struct work_struct *work)
{
    // å¯åœ¨æ­¤å¤„ sleepã€åˆ†é…å†…å­˜ï¼ˆGFP_KERNELï¼‰ã€è°ƒç”¨ I2C ç­‰
    msleep(100);
    dev_info(my_dev, "Work done!\n");
}

DECLARE_WORK(my_work, my_work_handler);
```

æ–¹å¼äºŒï¼šåŠ¨æ€åˆå§‹åŒ–ï¼ˆç”¨äºåµŒå…¥ç»“æ„ä½“ï¼‰

```c
struct my_device {
    struct work_struct work_name;
    int data;
};

void my_work_handler(struct work_struct *pwork)
{
    //container_ofæ‹¿åˆ°é©±åŠ¨ä¸­å…±äº«çš„æ•°æ®è¿›è¡Œåç»­é€»è¾‘
    struct my_device *mydev = container_of(pwork, struct my_device, work_name);
    // ä½¿ç”¨ mydev->data
}

// åˆå§‹åŒ–
INIT_WORK(&mydev->work, my_work_handler);
```



#### è°ƒåº¦å·¥ä½œé¡¹

```c
schedule_work(&my_work);          // æäº¤åˆ°ç³»ç»Ÿé»˜è®¤ workqueueï¼ˆsystem_wqï¼‰
```

> ç³»ç»Ÿé»˜è®¤ workqueue æ˜¯ `system_wq`ï¼ˆç»‘å®š CPUï¼Œæ”¯æŒå¹¶å‘ï¼‰ã€‚

#### å¸¦å»¶è¿Ÿè°ƒåº¦ï¼ˆå®šæ—¶æ‰§è¡Œï¼‰

```c
struct delayed_work my_delayed_work;

// åˆå§‹åŒ–
INIT_DELAYED_WORK(&my_delayed_work, my_delayed_handler);

// å»¶è¿Ÿ 2 ç§’åæ‰§è¡Œ
schedule_delayed_work(&my_delayed_work, msecs_to_jiffies(2000));

// å–æ¶ˆå»¶è¿Ÿå·¥ä½œï¼ˆè‹¥å°šæœªæ‰§è¡Œï¼‰
cancel_delayed_work(&my_delayed_work);
// æˆ–å®‰å…¨å–æ¶ˆï¼ˆç­‰å¾…æ‰§è¡Œå®Œï¼‰
cancel_delayed_work_sync(&my_delayed_work);
```

#### ä½¿ç”¨è‡ªå®šä¹‰ workqueueï¼ˆé«˜çº§ï¼‰

```c
struct workqueue_struct *my_wq;

// åˆ›å»ºå•çº¿ç¨‹ workqueueï¼ˆæŒ‰éœ€ï¼‰
my_wq = alloc_workqueue("my_wq", WQ_UNBOUND | WQ_MEM_RECLAIM, 1);

// è°ƒåº¦åˆ°è‡ªå®šä¹‰é˜Ÿåˆ—
queue_work(my_wq, &my_work);

// é”€æ¯
destroy_workqueue(my_wq);
```

> ä¸€èˆ¬é©±åŠ¨æ— éœ€è‡ªå®šä¹‰ï¼Œä½¿ç”¨ `system_wq` å³å¯ã€‚

**å®Œæ•´ç¤ºä¾‹**

```c
#include <linux/module.h>
#include <linux/workqueue.h>
#include <linux/delay.h>

static struct work_struct my_work;

static void my_work_handler(struct work_struct *work)
{
    printk(KERN_INFO "Work running in process context (PID %d)\n", current->pid);
    msleep(1000);  // âœ… åˆæ³•ï¼šå¯ç¡çœ 
    printk(KERN_INFO "Work done.\n");
}

static int __init work_init(void)
{
    INIT_WORK(&my_work, my_work_handler);
    schedule_work(&my_work);  // æäº¤å·¥ä½œ
    return 0;
}

static void __exit work_exit(void)
{
    // ç¡®ä¿ work å·²æ‰§è¡Œå®Œ
    flush_scheduled_work();  // ç­‰å¾… system_wq ä¸­æ‰€æœ‰ work å®Œæˆ
}

module_init(work_init);
module_exit(work_exit);
MODULE_LICENSE("GPL");
```

> `flush_scheduled_work()` å·²å¼ƒç”¨ï¼Œæ¨èä½¿ç”¨ `flush_work(&my_work)`ï¼ˆé’ˆå¯¹ç‰¹å®š workï¼‰ã€‚





#### Tasklet è¯¦è§£

- `tasklet` æ˜¯ä¸€ç§**è½¯ä¸­æ–­ï¼ˆsoftirqï¼‰** æœºåˆ¶ï¼Œåœ¨**ä¸­æ–­ä¸Šä¸‹æ–‡**æ‰§è¡Œã€‚
- **ä¸å¯ç¡çœ ã€ä¸å¯é˜»å¡**ï¼Œæ‰§è¡ŒæœŸé—´**æœ¬åœ° CPU ä¸­æ–­è¢«å…³é—­**ã€‚
- åŒä¸€ `tasklet` åœ¨æ‰§è¡Œå‰ä¸ä¼šè¢«é‡å¤è°ƒåº¦ï¼ˆè‡ªåŠ¨å»é‡ï¼‰ã€‚

> âš ï¸ **æ³¨æ„**ï¼šè‡ª Linux 5.0 èµ·ï¼Œ`tasklet` è¢«æ ‡è®°ä¸º **deprecated**ï¼ˆä¸æ¨èæ–°ä»£ç ä½¿ç”¨ï¼‰ã€‚



#### å¸¸ç”¨ API

é™æ€å®šä¹‰ï¼š

```c
void my_tasklet_handler(unsigned long data)
{
    // âŒ ä¸èƒ½ sleepï¼
    // âœ… å¯å¿«é€Ÿæ“ä½œç¡¬ä»¶ã€å”¤é†’è¿›ç¨‹ç­‰
    printk("Tasklet running on CPU %d\n", smp_processor_id());
}

DECLARE_TASKLET(my_tasklet, my_tasklet_handler, (unsigned long)my_dev);
```

åŠ¨æ€åˆå§‹åŒ–ï¼š

```c
struct tasklet_struct my_tasklet;

void my_tasklet_handler(unsigned long data)
{
    struct my_device *dev = (struct my_device *)data;
    // å¤„ç†
}

// åˆå§‹åŒ–
tasklet_init(&my_tasklet, my_tasklet_handler, (unsigned long)my_dev);//å¯ä»¥åœ°å€ä¼ å‚
```

#### è°ƒåº¦ tasklet

```c
tasklet_schedule(&my_tasklet);  // æ ‡è®°ä¸ºå¾…æ‰§è¡Œ
```

> å¤šæ¬¡è°ƒç”¨ `tasklet_schedule()` ä¸ä¼šé‡å¤æ‰§è¡Œï¼ˆç›´åˆ°å½“å‰æ‰§è¡Œå®Œæˆï¼‰ã€‚

#### ç¦ç”¨/å¯ç”¨ tasklet

```c
tasklet_disable(&my_tasklet);  // ç¦ç”¨ï¼ˆå¯åµŒå¥—ï¼‰
tasklet_enable(&my_tasklet);   // å¯ç”¨
```

#### é”€æ¯ taskletï¼ˆæ¨¡å—é€€å‡ºæ—¶ï¼‰

```c
tasklet_kill(&my_tasklet);  // ç­‰å¾…å…¶æ‰§è¡Œå®Œå¹¶ç¦ç”¨
```

> å¿…é¡»è°ƒç”¨ `tasklet_kill()`ï¼Œå¦åˆ™å¯èƒ½åœ¨æ¨¡å—å¸è½½åæ‰§è¡Œï¼Œå¯¼è‡´å´©æºƒã€‚



**Tasklet ç¤ºä¾‹ï¼ˆä»…ç”¨äºç†è§£ï¼Œä¸æ¨èæ–°é¡¹ç›®ä½¿ç”¨ï¼‰**

```c
#include <linux/module.h>
#include <linux/interrupt.h>

static struct tasklet_struct my_tasklet;

static void my_tasklet_handler(unsigned long data)
{
    printk(KERN_INFO "Tasklet: cannot sleep! CPU%d\n", smp_processor_id());
    // ä¸èƒ½è°ƒç”¨ msleep(), kmalloc(GFP_KERNEL) ç­‰
}

static int __init tasklet_init(void)
{
    tasklet_init(&my_tasklet, my_tasklet_handler, 0);
    tasklet_schedule(&my_tasklet);
    return 0;
}

static void __exit tasklet_exit(void)
{
    tasklet_kill(&my_tasklet);  // å¿…é¡»ï¼
}

module_init(tasklet_init);
module_exit(tasklet_exit);
MODULE_LICENSE("GPL");
```



| åœºæ™¯                              | æ¨èæœºåˆ¶                                           |
| --------------------------------- | -------------------------------------------------- |
| éœ€è¦ç¡çœ ï¼ˆå¦‚ I2Cã€USBã€æ–‡ä»¶æ“ä½œï¼‰ | âœ… `workqueue`                                      |
| éœ€è¦åˆ†é…å†…å­˜ï¼ˆ`GFP_KERNEL`ï¼‰      | âœ… `workqueue`                                      |
| ç®€å•æ•°æ®å¤„ç†ã€å”¤é†’ç­‰å¾…é˜Ÿåˆ—        | âœ… `workqueue`                                      |
| æä½å»¶è¿Ÿï¼ˆå¾®ç§’çº§ï¼‰ï¼Œä¸”é€»è¾‘æç®€å•  | âš ï¸ å¯è€ƒè™‘ `tasklet`ï¼ˆä½†ä¼˜å…ˆè€ƒè™‘çº¿ç¨‹åŒ–ä¸­æ–­ï¼‰         |
| æ–°é©±åŠ¨å¼€å‘                        | âŒ é¿å… `tasklet`ï¼Œç”¨ `workqueue` æˆ– `threaded IRQ` |

> ğŸ”§ **ç°ä»£æ›¿ä»£æ–¹æ¡ˆ**ï¼š
> å¯¹äºéœ€è¦â€œå¿«é€Ÿå“åº” + å¯ç¡çœ â€çš„åœºæ™¯ï¼Œ**çº¿ç¨‹åŒ–ä¸­æ–­ï¼ˆ`request_threaded_irq()`ï¼‰** æ˜¯æ›´ä¼˜é€‰æ‹©ï¼Œæ— éœ€æ‰‹åŠ¨è°ƒåº¦ä¸‹åŠéƒ¨ã€‚





### 5.çº¿ç¨‹åŒ–ä¸­æ–­

æ¨èç”¨äºå¤æ‚å¤„ç†

å½“éœ€è¦åœ¨ä¸­æ–­ä¸­æ‰§è¡Œå¯èƒ½é˜»å¡çš„æ“ä½œï¼ˆå¦‚ I2C é€šä¿¡ã€æ–‡ä»¶æ“ä½œç­‰ï¼‰ï¼Œåº”ä½¿ç”¨ **çº¿ç¨‹åŒ–ä¸­æ–­**ã€‚å®ƒå°†ä¸­æ–­åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼š

- **ä¸ŠåŠéƒ¨ï¼ˆhardirqï¼‰**ï¼šæç®€ï¼Œä»…å”¤é†’å†…æ ¸çº¿ç¨‹ã€‚
- **ä¸‹åŠéƒ¨ï¼ˆthread_fnï¼‰**ï¼šåœ¨å†…æ ¸çº¿ç¨‹ä¸­è¿è¡Œï¼Œå¯ç¡çœ ã€‚



#### **`request_threaded_irq`**

```c
/*
 * handlerï¼šå¯ä¸º NULLï¼ˆè¡¨ç¤ºé»˜è®¤åªåš ACK å’Œå”¤é†’çº¿ç¨‹ï¼‰ã€‚
 * thread_fnï¼šå®é™…å¤„ç†å‡½æ•°ï¼ˆå¯ç¡çœ ï¼‰ã€‚
 * è‹¥ handler é NULLï¼Œéœ€è¿”å› IRQ_WAKE_THREAD æ‰ä¼šè°ƒç”¨ thread_fnã€‚
 */
int request_threaded_irq(unsigned int irq, irq_handler_t handler, irq_handler_t thread_fn,
                         unsigned long flags, const char *name, void *dev);
```

ç¤ºä¾‹

```c
static irqreturn_t my_irq_handler(int irq, void *dev)
{
    // å¿«é€Ÿåˆ¤æ–­æ˜¯å¦æ˜¯æœ¬è®¾å¤‡çš„ä¸­æ–­ï¼ˆå¦‚è¯»çŠ¶æ€å¯„å­˜å™¨ï¼‰
    if (!is_my_device_interrupt())
        return IRQ_NONE;
    return IRQ_WAKE_THREAD; // å”¤é†’çº¿ç¨‹
}

static irqreturn_t my_irq_thread_fn(int irq, void *dev)
{
    // å¯åœ¨æ­¤å¤„ sleepã€è°ƒç”¨ I2Cã€printk ç­‰
    msleep(10);  // âœ… åˆæ³•
    i2c_smbus_read_byte(...);
    return IRQ_HANDLED;
}

// æ³¨å†Œ
request_threaded_irq(irq, my_irq_handler, my_irq_thread_fn,
                     IRQF_ONESHOT | IRQF_TRIGGER_FALLING,
                     "my-device", my_dev);
```

> **å…³é”®ç‚¹**ï¼š
>
> - å¿…é¡»æŒ‡å®š `IRQF_ONESHOT`ï¼šè¡¨ç¤ºä¸­æ–­çº¿åœ¨ thread_fn å®Œæˆå‰ä¿æŒå…³é—­ï¼Œé˜²æ­¢åµŒå¥—ã€‚
> - è‹¥ `handler` ä¸º `NULL`ï¼Œå†…æ ¸è‡ªåŠ¨å¤„ç† ACK å¹¶å”¤é†’çº¿ç¨‹ã€‚





## åã€ä¼‘çœ ä¸å”¤é†’



![016](img\016.png)

### æ ¸å¿ƒæ•°æ®ç»“æ„

```c
#include <linux/wait.h>

// ç­‰å¾…é˜Ÿåˆ—å¤´
struct wait_queue_head {
    spinlock_t lock;
    struct list_head head;
};
typedef struct wait_queue_head wait_queue_head_t;

// ç­‰å¾…é˜Ÿåˆ—é¡¹ï¼ˆä»£è¡¨ä¸€ä¸ªç­‰å¾…è€…ï¼‰
struct wait_queue_entry {
    unsigned int flags;
    void *private;        // é€šå¸¸æŒ‡å‘ task_struct
    wait_queue_func_t func; // å”¤é†’å›è°ƒå‡½æ•°
    struct list_head entry;
};
```

å®šä¹‰ç­‰å¾…é˜Ÿåˆ—å¤´ï¼š

```c
DECLARE_WAIT_QUEUE_HEAD(my_wait_queue);
// æˆ–åŠ¨æ€åˆå§‹åŒ–ï¼š
wait_queue_head_t my_waitq;
init_waitqueue_head(&my_waitq);
```



### ä¼‘çœ ä¸å”¤é†’çš„æ ¸å¿ƒAPI

#### ä¼‘çœ api

- **`wait_event(queue, condition)`**
  ä¸å¯ä¸­æ–­ä¼‘çœ ï¼Œæ¡ä»¶ä¸ºçœŸæ—¶ç»§ç»­ã€‚
  æ³¨æ„ï¼šæ­¤å‡½æ•°åªèƒ½åœ¨**è¿›ç¨‹ä¸Šä¸‹æ–‡**ä½¿ç”¨ã€‚
- **`wait_event_interruptible(queue, condition)`**
  å¯è¢«ä¿¡å·ä¸­æ–­çš„ä¼‘çœ ã€‚è‹¥è¢«ä¿¡å·ä¸­æ–­ï¼Œè¿”å› `-ERESTARTSYS`ã€‚
- **`wait_event_timeout(queue, condition, timeout)`**
  å¸¦è¶…æ—¶çš„ä¸å¯ä¸­æ–­ä¼‘çœ ï¼Œè¶…æ—¶è¿”å›å‰©ä½™jiffiesï¼ˆ0è¡¨ç¤ºè¶…æ—¶ï¼‰ã€‚
- **`wait_event_interruptible_timeout(...)`**
  å¯ä¸­æ–­ + è¶…æ—¶ç‰ˆæœ¬ã€‚

> è¿™äº›å®å†…éƒ¨ä¼šï¼š
>
> 1. æ£€æŸ¥æ¡ä»¶æ˜¯å¦ä¸ºçœŸï¼Œè‹¥æ˜¯ï¼Œç«‹å³è¿”å›ï¼›
> 2. è‹¥å¦ï¼Œå°†å½“å‰è¿›ç¨‹åŠ å…¥ç­‰å¾…é˜Ÿåˆ—ï¼›
> 3. è®¾ç½®è¿›ç¨‹çŠ¶æ€ä¸º `TASK_INTERRUPTIBLE` æˆ– `TASK_UNINTERRUPTIBLE`ï¼›
> 4. è°ƒç”¨ `schedule()` è®©å‡ºCPUï¼›
> 5. è¢«å”¤é†’åé‡æ–°æ£€æŸ¥æ¡ä»¶ï¼ˆ**å¿…é¡»æ˜¯å¾ªç¯æ£€æŸ¥ï¼**ï¼‰ã€‚

#### å”¤é†’api

- **`wake_up(&wait_queue_head)`**
  å”¤é†’æ‰€æœ‰å¤„äº `TASK_INTERRUPTIBLE` å’Œ `TASK_UNINTERRUPTIBLE` çŠ¶æ€çš„ç­‰å¾…è€…ã€‚
- **`wake_up_interruptible(&wait_queue_head)`**
  ä»…å”¤é†’ `TASK_INTERRUPTIBLE` çŠ¶æ€çš„è¿›ç¨‹ï¼ˆé€šå¸¸ç”¨äºå¯ä¸­æ–­ä¼‘çœ ï¼‰ã€‚
- **`wake_up_all()` / `wake_up_interruptible_all()`**
  å”¤é†’æ‰€æœ‰åŒ¹é…çŠ¶æ€çš„ç­‰å¾…è€…ï¼ˆä¸æ™®é€š `wake_up` ç±»ä¼¼ï¼Œä½†è¯­ä¹‰æ›´æ˜ç¡®ï¼‰ã€‚





#### ç­‰å¾…é˜Ÿåˆ—

1.åˆ›å»ºç­‰å¾…é˜Ÿåˆ—å¤´


`init_waitqueue_head(wait_queue_head_t  *wq)`

2.åˆ¤æ–­æ˜¯å¦éœ€è¦ç­‰å¾…

`wait_event_interruptible()`

3.å”¤é†’ç­‰å¾…é˜Ÿåˆ—

`wake_up_interruptible()`





### å…¸å‹ä½¿ç”¨æ¨¡å¼ï¼ˆä»¥å­—ç¬¦è®¾å¤‡ä¸ºä¾‹ï¼‰

```c
static DECLARE_WAIT_QUEUE_HEAD(mydev_wq);
static volatile int data_ready = 0;

// é©±åŠ¨ä¸­çš„ read å‡½æ•°
ssize_t mydev_read(struct file *filp, char __user *buf, size_t count, loff_t *off)
{
    // ç­‰å¾…æ•°æ®å°±ç»ªï¼ˆå¯è¢«ä¿¡å·ä¸­æ–­ï¼‰
    if (wait_event_interruptible(mydev_wq, data_ready)) {
        return -ERESTARTSYS; // è¢«ä¿¡å·ä¸­æ–­
    }

    // æ­¤æ—¶ data_ready ä¸ºçœŸï¼Œå¯å®‰å…¨è¯»å–æ•°æ®
    // ... copy_to_user ...
    data_ready = 0; // é‡ç½®æ ‡å¿—ï¼ˆå‡è®¾ä¸€æ¬¡è¯»å–æ¶ˆè€—ä¸€ä¸ªäº‹ä»¶ï¼‰
    return actual_bytes;
}

// ä¸­æ–­å¤„ç†å‡½æ•°ï¼ˆæˆ–å†…æ ¸çº¿ç¨‹ï¼‰
irqreturn_t mydev_irq_handler(int irq, void *dev_id)
{
    // å¤„ç†ä¸­æ–­ï¼Œæ ‡è®°æ•°æ®å°±ç»ª
    data_ready = 1;
    wake_up_interruptible(&mydev_wq); // å”¤é†’ç­‰å¾…è€…
    return IRQ_HANDLED;
}
```

> âœ… **å…³é”®ç‚¹**ï¼š
>
> - `data_ready` åº”è¯¥è¢« `volatile` ä¿®é¥°ï¼ˆæˆ–é…åˆå†…å­˜å±éšœï¼‰ï¼›
> - æ¡ä»¶æ£€æŸ¥å’Œå”¤é†’å¿…é¡»**åŸå­æ€§åè°ƒ**ï¼ˆé€šå¸¸ç”¨è‡ªæ—‹é”æˆ–äº’æ–¥é”ä¿æŠ¤ï¼‰ï¼›
> - ä½¿ç”¨ `wake_up_interruptible()` ä¸ `wait_event_interruptible()` é…å¯¹ã€‚



### æ³¨æ„äº‹é¡¹ä¸æœ€ä½³å®è·µ

**a.åªèƒ½åœ¨è¿›ç¨‹ä¸Šä¸‹æ–‡ä¼‘çœ **
ä¸­æ–­ä¸Šä¸‹æ–‡ã€åŸå­ä¸Šä¸‹æ–‡ï¼ˆå¦‚æŒæœ‰è‡ªæ—‹é”æ—¶ï¼‰ä¸èƒ½è°ƒç”¨ä¼‘çœ å‡½æ•°ï¼Œå¦åˆ™ä¼šå¯¼è‡´ç³»ç»Ÿå´©æºƒï¼ˆ`might_sleep()` ä¼šå‘Šè­¦ï¼‰ã€‚

**b.é¿å…ç«äº‰æ¡ä»¶**
æ¡ä»¶å˜é‡ï¼ˆå¦‚ `data_ready`ï¼‰çš„è¯»å†™é€šå¸¸éœ€è¦åŠ é”ã€‚æ¨èä½¿ç”¨è‡ªæ—‹é”ï¼ˆè‹¥åœ¨ä¸­æ–­ä¸Šä¸‹æ–‡ä¿®æ”¹ï¼‰æˆ–äº’æ–¥é”ã€‚

**c.æ¡ä»¶æ£€æŸ¥å¿…é¡»åœ¨ä¸´ç•ŒåŒºå†…å®Œæˆ**

```c
spin_lock_irqsave(&my_lock, flags);
data_ready = 1;
spin_unlock_irqrestore(&my_lock, flags);
wake_up_interruptible(&my_wq);

// åœ¨ wait_event ä¸­ä¹Ÿéœ€é”ä¿æŠ¤æ¡ä»¶æ£€æŸ¥ï¼ˆwait_eventå†…éƒ¨ä¸åŠ é”ï¼ï¼‰
wait_event_interruptible(my_wq, ({
    int ready;
    spin_lock_irqsave(&my_lock, flags);
    ready = data_ready;
    spin_unlock_irqrestore(&my_lock, flags);
    ready;
}));
```

**d.ä¼˜å…ˆä½¿ç”¨ `wait_event_interruptible`**
é™¤éè®¾å¤‡å¿…é¡»ä¸å¯ä¸­æ–­ï¼ˆå¦‚ç£ç›˜I/Oï¼‰ï¼Œå¦åˆ™åº”æ”¯æŒä¿¡å·ä¸­æ–­ï¼Œæå‡ç”¨æˆ·ä½“éªŒã€‚

**e.é¿å…é•¿æ—¶é—´ä¸å¯ä¸­æ–­ä¼‘çœ **
`TASK_UNINTERRUPTIBLE` ä¼šå¯¼è‡´è¿›ç¨‹æ— æ³•è¢« killï¼Œç”¨æˆ·æ€è¡¨ç°ä¸ºâ€œDçŠ¶æ€â€ï¼ˆuninterruptible sleepï¼‰ï¼Œåº”æ…ç”¨ã€‚





## åä¸€ã€å¹³å°æ€»çº¿é©±åŠ¨æ¨¡å‹

å¹³å°æ€»çº¿ï¼ˆPlatform Busï¼‰æ˜¯ Linux å†…æ ¸ä¸­ä¸€ç§é‡è¦çš„è™šæ‹Ÿæ€»çº¿æœºåˆ¶ï¼Œç”¨äºç®¡ç†é‚£äº›**ä¸é€šè¿‡ç‰©ç†æ€»çº¿ï¼ˆå¦‚ PCIã€USBã€I2Cã€SPI ç­‰ï¼‰è¿æ¥åˆ°ç³»ç»Ÿçš„è®¾å¤‡**ã€‚è¿™äº›è®¾å¤‡é€šå¸¸æ˜¯ SoCï¼ˆç‰‡ä¸Šç³»ç»Ÿï¼‰å†…éƒ¨é›†æˆçš„å¤–è®¾ï¼ˆå¦‚ UARTã€GPIOã€å®šæ—¶å™¨ã€çœ‹é—¨ç‹—ã€PWMã€DMA æ§åˆ¶å™¨ç­‰ï¼‰ï¼Œæˆ–è€…æ˜¯ç³»ç»Ÿä¸­â€œå›ºå®šå­˜åœ¨â€çš„ç¡¬ä»¶èµ„æºã€‚



### **å¹³å°æ€»çº¿çš„ä¸‰è¦ç´ **

1. **å¹³å°è®¾å¤‡ï¼ˆplatform_deviceï¼‰**
   - æè¿°ç¡¬ä»¶ä¿¡æ¯ï¼šå¦‚å†…å­˜åœ°å€ã€ä¸­æ–­å·ã€DMA é€šé“ã€æ—¶é’Ÿã€å¼•è„šå¤ç”¨ç­‰ã€‚
   - ç”±è®¾å¤‡æ ‘ï¼ˆDevice Treeï¼‰æˆ–æ¿çº§æ–‡ä»¶ï¼ˆæ—§ç‰ˆï¼‰é™æ€å®šä¹‰ã€‚
2. **å¹³å°é©±åŠ¨ï¼ˆplatform_driverï¼‰**
   - å®ç°è®¾å¤‡æ“ä½œé€»è¾‘ï¼šprobeã€removeã€suspendã€resume ç­‰ã€‚
   - é€šè¿‡ `name` æˆ– `of_match_table` ä¸è®¾å¤‡åŒ¹é…ã€‚
3. **å¹³å°æ€»çº¿ï¼ˆplatform_busï¼‰**
   - è™šæ‹Ÿæ€»çº¿ï¼Œè´Ÿè´£è®¾å¤‡ä¸é©±åŠ¨çš„åŒ¹é…å’Œç”Ÿå‘½å‘¨æœŸç®¡ç†ã€‚



### å¹³å°è®¾å¤‡ä¸é©±åŠ¨çš„åŒ¹é…æœºåˆ¶

æŒ‰ä¼˜å…ˆçº§

1. **è®¾å¤‡æ ‘åŒ¹é…ï¼ˆä¸»æµæ–¹å¼ï¼Œç°ä»£ SoC åŸºæœ¬éƒ½ç”¨ï¼‰**

```dtd
my_device: my-device@12340000 {
    compatible = "vendor,my-device";
    reg = <0x12340000 0x1000>;  // å¯„å­˜å™¨åŸºåœ°å€å’Œå¤§å°
    interrupts = <0 25 4>;       // ä¸­æ–­å·
    clocks = <&clkc CLK_UART>;
    status = "okay";
};
```



```c
static const struct of_device_id my_driver_of_match[] = {
    { .compatible = "vendor,my-device" },
    { /* sentinel */ }
};
MODULE_DEVICE_TABLE(of, my_driver_of_match);

static struct platform_driver my_driver = {
    .probe = my_probe,
    .remove = my_remove,
    .driver = {
        .name = "my-device",
        .of_match_table = my_driver_of_match,
    },
};
```

2. **ACPI åŒ¹é…ï¼ˆç”¨äº x86 å¹³å°ï¼‰**
3. **ID è¡¨åŒ¹é…ï¼ˆ`id_table`ï¼Œè¾ƒå°‘ç”¨ï¼‰**
4. **name å­—ç¬¦ä¸²åŒ¹é…ï¼ˆæœ€è€æ–¹å¼ï¼Œä¸æ¨èï¼‰**

> è®¾å¤‡æ ‘åŒ¹é…ä¼˜å…ˆçº§æœ€é«˜ã€‚ä¸€æ—¦å®šä¹‰äº† `of_match_table`ï¼Œå†…æ ¸ä¼šä¼˜å…ˆä½¿ç”¨è®¾å¤‡æ ‘åŒ¹é…ï¼Œå¿½ç•¥ `.name`ã€‚



### 1.å¹³å°è®¾å¤‡

ç¤ºä¾‹ä»£ç 

```c
#include <linux/module.h>
#include <linux/init.h>
#include <linux/platform_device.h>
#include "led.h"

//åˆ›å»º3ä¸ªå¼•è„šå¯¹è±¡
static struct rk_gpio_led rk_leds[] = {
	[0] = {
		.gpio = 13,
		.desc = "gpio_led1",
	},
};

//åˆ›å»ºè‡ªå®šä¹‰å¹³å°æ•°æ®å¯¹è±¡
static struct leds_platform_data rk_led_platform_data = {
	.leds = rk_leds,
	.nleds = ARRAY_SIZE(rk_leds),
};


//å®šä¹‰èµ„æºå¯¹è±¡ï¼Œç‰©ç†åœ°å€ä¿¡æ¯ï¼Œä½¿ç”¨æ—¶è¿›è¡Œioremapæ“ä½œ
static struct resource led_resources[] = {
	[0] = {
		.start	= CRU_CLKGATE_CON31, //èµ·å§‹åœ°å€
		.end	= CRU_CLKGATE_CON31 + SIZE_4 - 1, //ç»“æŸåœ°å€
		.flags	= IORESOURCE_MEM, //åœ°å€ç±»å‹
	},
	[1] = {
		.start	= GRF_GPIO2A_IOMUX,
		.end	= GRF_GPIO2A_IOMUX + SIZE_4 - 1,
		.flags	= IORESOURCE_MEM, //åœ°å€ç±»å‹
	},
	[2] = {
		.start	= 75,
		.end	= 75,
		.flags	= IORESOURCE_IRQ, //ä¸­æ–­ç±»å‹
	},
	
	[3] = {
		.start	= GPIO2_SWPORTA_DDR,
		.end	= GPIO2_SWPORTA_DDR + SIZE_4 - 1,
		.flags	= IORESOURCE_MEM, //åœ°å€ç±»å‹
	},
	
	[4] = {
		.start	= GPIO2_SWPORTA_DR,
		.end	= GPIO2_SWPORTA_DR + SIZE_4 - 1,
		.flags	= IORESOURCE_MEM, //åœ°å€ç±»å‹
	},
};

//è®¾å¤‡æ¨å‡ºçš„å‡½æ•°
static void led_release(struct device *dev)
{
	printk("%s run device >%s >%d\n",current->comm, __func__, __LINE__);
}


/*
 * å®šä¹‰å¹³å°è®¾å¤‡å¯¹è±¡
 */
static struct platform_device led_device = {
	.name = "rk_led1",   							// å¹³å°è®¾å¤‡å¯¹è±¡çš„åç§°
	.id = -1,
	.dev = {
		.release = led_release, 					//è®¾å¤‡æ³¨é”€æ—¶éœ€è¦çš„å‡½æ•°
		.platform_data = &rk_led_platform_data, 	//è‡ªå®šä¹‰çš„è®¾å¤‡æ•°æ®
	},
	.resource = led_resources, 						// èµ„æºç»„
	.num_resources = ARRAY_SIZE(led_resources), 	// èµ„æºç»„é•¿åº¦
};

//å…¥å£
static int __init dev_led_init(void)
{
	printk("%s run >%s >%d\n",current->comm, __func__, __LINE__);
	//æ³¨å†Œå¹³å°è®¾å¤‡
	return platform_device_register(&led_device);
}

//å‡ºå£
static void __exit dev_led_exit(void)
{
	printk("%s run device >%s >%d\n",current->comm, __func__, __LINE__);
	//æ³¨é”€å¹³å°è®¾å¤‡
	platform_device_unregister(&led_device);
}


module_init(dev_led_init);
module_exit(dev_led_exit);
MODULE_LICENSE("GPL");
```



#### è°ƒè¯•

è£…è½½å¹³å°è®¾å¤‡åè¿›å…¥ç³»ç»Ÿç›®å½•æŸ¥çœ‹

```bash
root@NanoPC-T4:~# ll /sys/bus/platform/devices/rk_led1/
drwxr-xr-x   3 root root    0 Dec 14 08:05 ./
drwxr-xr-x 154 root root    0 Dec 14 07:27 ../
lrwxrwxrwx   1 root root    0 Dec 14 08:05 driver -> ../../../bus/platform/drivers/rk_led/ # åŒ¹é…åˆ°çš„é©±åŠ¨
-rw-r--r--   1 root root 4096 Dec 14 08:05 driver_override
-r--r--r--   1 root root 4096 Dec 14 08:05 modalias
drwxr-xr-x   2 root root    0 Dec 14 08:05 power/
lrwxrwxrwx   1 root root    0 Dec 14 08:05 subsystem -> ../../../bus/platform/
-rw-r--r--   1 root root 4096 Dec 14 07:33 uevent

```





### 2.å¹³å°é©±åŠ¨

ç¤ºä¾‹ä»£ç 

```c
#include <linux/module.h>
#include <linux/init.h>
#include <linux/platform_device.h>
#include <linux/fs.h>
#include <linux/device.h>
#include <linux/slab.h>
#include <linux/gpio.h>
#include <linux/uaccess.h>
#include "led.h"

//å®šä¹‰ä¸€ä¸ªledè®¾å¤‡çš„ç»“æ„ä½“(ç±»)
struct rk_led {
	unsigned int major;//ä¸»è®¾å¤‡å·
	struct class *cls;//è®¾å¤‡ç±»
	struct device *dev;//å­—ç¬¦è®¾å¤‡
	int gpio_led; //ä¿å­˜å¼•è„šå·
	int value; //ä¿å­˜onå€¼
};

static struct rk_led  *led_device; //å£°æ˜ä¸€ä¸ªå¯¹è±¡ä¸ºrk_ledçš„æŒ‡é’ˆ

static int led_open(struct inode *inode, struct file *filp)
{
	printk("%s run driver >%s >%d\n",current->comm, __func__, __LINE__);
	return 0;
}

static int led_close (struct inode *inode, struct file *filp)
{
	gpio_direction_output(led_device->gpio_led, 0); //led off
	printk("%s run driver >%s >%d\n",current->comm, __func__, __LINE__);
	return 0;
}
static ssize_t led_write (struct file *filp, const char __user *buf, size_t size, loff_t *flag)
{
	int ret;
	led_device->value = 0;
	ret = copy_from_user(&led_device->value, buf, size);
	if (ret) {
		printk("copy_from_user fail\n");
		return -EFAULT;
	}
	printk("<kernel> write: %d\n", led_device->value);
	if (led_device->value) {
		printk("led on \n");
		gpio_direction_output(led_device->gpio_led, 1); //led on
	} else {
		printk("led off \n");
		gpio_direction_output(led_device->gpio_led, 0); //led off
	}
	printk("%s run driver >%s >%d\n",current->comm, __func__, __LINE__);
	return 0;
}

static struct file_operations fops = {
	.owner = THIS_MODULE, //é¿å…åœ¨ç”¨æ—¶å¸è½½æ¨¡å—
	.open = led_open,
	.write = led_write,
	.release = led_close,
}; //å®šä¹‰æ–‡ä»¶æ“ä½œæ¥å£ open ,close



//å½“å¹³å°è®¾å¤‡å’Œå¹³å°é©±åŠ¨åŒ¹é…æ—¶ä¼šè°ƒç”¨probeå‡½æ•°
//å‚æ•°pdevå°±æ˜¯åŒ¹é…ä¸Šçš„å¹³å°è®¾å¤‡å¯¹è±¡
//åœ¨è¿™é‡Œåˆ›å»ºè®¾å¤‡æ–‡ä»¶
static int led_probe(struct platform_device *pdev)
{
	int ret;
	//1.æ‹¿åˆ°è®¾å¤‡ä¼ è¿‡æ¥çš„è‡ªå®šä¹‰æ•°æ®
	struct leds_platform_data *pdata = (struct leds_platform_data *)pdev->dev.platform_data;
	led_device = kmalloc(sizeof(struct rk_led), GFP_KERNEL);
	if (!led_device) {
		printk("kmalloc fail\n");
		return -ENOMEM;
	}
	//2.æ³¨å†Œå­—ç¬¦è®¾å¤‡å¯¹è±¡
	led_device->major = register_chrdev(0, "led_drv", &fops);
	if (led_device->major < 0) {
		printk("register_chrdev fail\n");
		ret = -EBUSY;
		goto err_register_chrdev;
	}
	printk("%s run driver >%s >%d major=%d\n", current->comm, __func__, __LINE__, led_device->major);
	//3.åˆ›å»ºè®¾å¤‡ç±»å¯¹è±¡
	led_device->cls = class_create(THIS_MODULE, "led_cls");
	if (IS_ERR(led_device->cls)) { //æµ‹è¯•åˆ›å»ºæ˜¯å¦æˆåŠŸ,æˆç«‹å°±å¤±è´¥
		ret = PTR_ERR(led_device->cls);
		goto err_class_create;
	}
	//4.åˆ›å»ºè®¾å¤‡å¯¹è±¡(è®¾å¤‡æ–‡ä»¶)
	led_device->dev = device_create(led_device->cls, NULL, MKDEV(led_device->major, 32), NULL, "led");
	if (IS_ERR(led_device->dev)) {
		ret = PTR_ERR(led_device->dev);
		goto err_device_create;
	}
	//5.åˆå§‹åŒ–ç¡¬ä»¶
	led_device->gpio_led = pdata->leds[0].gpio; //GPIO0_B5
	//6.ç”³è¯·å¼•è„š
	ret = gpio_request(led_device->gpio_led, pdata->leds[0].desc);
	if (ret) {
		printk("gpio_request fail\n");
		goto err_gpio_request;
	}
	//è®¾ç½®å¼•è„šä¸ºè¾“å‡ºåŠŸèƒ½
	gpio_direction_output(led_device->gpio_led, 0); //é»˜è®¤led off
	//é‡Šæ”¾å¼•è„š
	gpio_free(led_device->gpio_led);
	printk("%s run driver >%s >%d register done.\n", current->comm, __func__, __LINE__);
	return 0;

err_gpio_request:
	device_destroy(led_device->cls, MKDEV(led_device->major, 32));
err_device_create:
	class_destroy(led_device->cls);
err_class_create:
	unregister_chrdev(led_device->major, "led_drv");
err_register_chrdev:
	kfree(led_device);
	return ret;
}

//å½“å¹³å°è®¾å¤‡å’Œå¹³å°é©±åŠ¨åˆ†ç¦»æ—¶ä¼šè°ƒç”¨removeå‡½æ•°
static int led_remove(struct platform_device *pdev)
{
	//å…ˆç”³è¯·åé‡Šæ”¾
	device_destroy(led_device->cls, MKDEV(led_device->major, 32));
	class_destroy(led_device->cls);
	unregister_chrdev(led_device->major, "led_drv");
	kfree(led_device);
	printk("%s run driver >%s >%d\n",current->comm, __func__, __LINE__);
	return 0;
}

//å®šä¹‰å¹³å°è®¾å¤‡IDï¼Œå¯ä»¥ç”¨æ¥åŒ¹é…åŒç±»å‹è®¾å¤‡ï¼Œä¸€é©±åŠ¨å¤šè®¾å¤‡
static struct platform_device_id led_device_id_table[] = {
	{ .name = "rk_led1", .driver_data = 0x1 },
	{ .name = "rk_led2", .driver_data = 0x2 },
	{ .name = "rk_led3", .driver_data = 0x3 },
	{ .name = "rk_led4", .driver_data = 0x4 },
    {},
};

//å¹³å°é©±åŠ¨å¯¹è±¡
static struct platform_driver led_driver = {
	.probe	= led_probe,  				//åŒ¹é…åˆ°è®¾å¤‡è‡ªåŠ¨è°ƒç”¨
	.remove	= led_remove,  				//è®¾å¤‡é‡Šæ”¾æ—¶è‡ªåŠ¨
	.driver	= {
		.name = "rk_led", 				//å¹³å°é©±åŠ¨åç§°,åˆæ˜¯åŒ¹é…æ¡ä»¶
	},
	.id_table = led_device_id_table,    //å½“id_tableè¢«å®šä¹‰æ—¶ï¼Œä¼˜å…ˆä½¿ç”¨è¿™ä¸ªå±æ€§é‡Œçš„åç§°åŒ¹é…è®¾å¤‡
};

//å‡ºå£
static int __init drv_mod_init(void) 
{
	printk("%s run driver >%s >%d\n",current->comm, __func__, __LINE__);
	return platform_driver_register(&led_driver);
}

//å…¥å£
static void __exit drv_mod_exit(void) 
{
	printk("%s run driver >%s >%d\n",current->comm, __func__, __LINE__);
	platform_driver_unregister(&led_driver);
}

module_init(drv_mod_init);
module_exit(drv_mod_exit);
MODULE_LICENSE("GPL"); 
```

**æ³¨æ„**ï¼š`id_table`åŒ¹é…ä¼˜å…ˆäº`driver.name`



#### è°ƒè¯•

```bash
root@NanoPC-T4:~# ll /sys/bus/platform/drivers/rk_led/
total 0
drwxr-xr-x   2 root root    0 Dec 14 08:10 ./
drwxr-xr-x 120 root root    0 Dec 14 07:27 ../
--w-------   1 root root 4096 Dec 14 08:10 bind
lrwxrwxrwx   1 root root    0 Dec 14 08:10 module -> ../../../../module/led_drv/
lrwxrwxrwx   1 root root    0 Dec 14 08:10 rk_led1 -> ../../../../devices/platform/rk_led1/  #åŒ¹é…åˆ°çš„è®¾å¤‡
--w-------   1 root root 4096 Dec 14 07:33 uevent
--w-------   1 root root 4096 Dec 14 08:10 unbind
```

å†…æ ¸æ—¥å¿—

```bash
dmesg | grep my-device
```





#### ä¼ é€’æ•°æ®ç»™é©±åŠ¨

- ä»resourceså±æ€§ä¼ é€’

```c
static int led_probe(struct platform_device *pdev)
{
	int i;
	int irqno;
	struct resource *addr_res; //åœ°å€èµ„æº
	struct resource *irq_res; //ä¸­æ–­èµ„æº
	for (i = 0 ; i < 4; i++) {
		addr_res = platform_get_resource(pdev, IORESOURCE_MEM, i);   //ä½¿ç”¨è¿™ä¸ªå®ä»å¹³å°è®¾å¤‡è¿‡æ»¤å‡ºç‰¹å®šç±»å‹æ•°æ®
		printk("<kernel> addr_res->star=0x%llx end=0x%llx\n", addr_res->start, addr_res->end);
	}

	irq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);   //è¿‡æ»¤ç‰¹å®šç±»å‹æ•°æ®
	printk("<kernel> irq_res->star=%lld end=%lld\n", irq_res->start, irq_res->end);
    //ä»å¹³å°è®¾å¤‡ä¸­ç›´æ¥æ‹¿ä¸­æ–­å·ï¼›å‚æ•°1ï¼šå¹³å°è®¾å¤‡  å‚æ•°2ï¼šç¬¬å‡ ä¸ªèµ„æº   å¤±è´¥è¿”å›-1
	irqno = platform_get_irq(pdev, 0);
	printk("<kernel> irqno=%d\n", irqno);
	printk("call %s() @ %d\n", __func__, __LINE__);
	return 0;
}
```

- ä»platform_dataä¼ é€’è‡ªå®šä¹‰ç±»å‹æ•°æ®

```c
static int led_probe(struct platform_device *pdev)
{
	int ret = 0;
    //ä½¿ç”¨å¯¹è±¡æŒ‡é’ˆå¼ºè½¬
	struct leds_platform_data *pdata = (struct leds_platform_data *)pdev->dev.platform_data;
   	
    return ret;
}
```



### 3.å…¶ä»–å¸¸ç”¨API

| å‡½æ•° | è¯´æ˜ |
|------|------|
| `platform_get_resource()` | è·å–å†…å­˜ã€IOã€IRQ ç­‰èµ„æº |
| `devm_ioremap_resource()` | æ˜ å°„å¯„å­˜å™¨ï¼ˆè‡ªåŠ¨é‡Šæ”¾ï¼‰ |
| `platform_get_irq()` | è·å–ä¸­æ–­å· |
| `devm_clk_get()` | è·å–æ—¶é’Ÿï¼ˆè‡ªåŠ¨ç®¡ç†ï¼‰ |
| `devm_reset_control_get()` | è·å–å¤ä½æ§åˆ¶å™¨ |
| `of_property_read_u32()` | è¯»å–è®¾å¤‡æ ‘å±æ€§ |



**æ³¨æ„äº‹é¡¹**

- å¿…é¡»ä½¿ç”¨ devm_ ç³»åˆ—å‡½æ•°

  - ä½¿ç”¨ **`devm_ioremap_resource()`**ã€**`devm_clk_get()`** ç­‰ï¼Œç¡®ä¿èµ„æºåœ¨é©±åŠ¨å¸è½½æ—¶è‡ªåŠ¨é‡Šæ”¾ã€‚

  - é¿å…å†…å­˜æ³„æ¼å’Œèµ„æºå†²çªã€‚

- é”™è¯¯å¤„ç†

  - probe å‡½æ•°è¿”å›è´Ÿé”™è¯¯ç ï¼ˆå¦‚ `-ENOMEM`, `-EINVAL`ï¼‰ï¼Œä¸è¦è¿”å› 0 ä»¥å¤–çš„æˆåŠŸå€¼ã€‚

  - èµ„æºè·å–å¤±è´¥å¿…é¡»è¿”å›é”™è¯¯ï¼Œé¿å…åç»­ä½¿ç”¨ç©ºæŒ‡é’ˆã€‚





## åäºŒã€è®¾å¤‡æ ‘



ç¼–è¯‘è®¾å¤‡æ ‘ï¼š`make dtbs`

```bash
robin@ubuntu:~/work/kernel-rockchip-nanopi4-linux-v4.4.y$ make dtbs
  CHK     include/config/kernel.release
  CHK     include/generated/uapi/linux/version.h
...
  VDSOSYM include/generated/vdso-offsets.h
  HOSTCC  scripts/dtc/dtc.o
...
  HOSTCC  scripts/sortextable
  HOSTCC  scripts/asn1_compiler
  HOSTCC  scripts/extract-cert
  DTC     arch/arm64/boot/dts/rockchip/rk3399-nanopi4-rev00.dtb
  DTC     arch/arm64/boot/dts/rockchip/rk3399-nanopi4-rev01.dtb
  DTC     arch/arm64/boot/dts/rockchip/rk3399-nanopi4-rev04.dtb
  DTC     arch/arm64/boot/dts/rockchip/rk3399-nanopi4-rev06.dtb
  DTC     arch/arm64/boot/dts/rockchip/rk3399-nanopi4-rev07.dtb
  DTC     arch/arm64/boot/dts/rockchip/rk3399-nanopi4-rev21.dtb
  DTC     arch/arm64/boot/dts/rockchip/rk3399-nanopi4-rev22.dtb
  DTC     arch/arm64/boot/dts/rockchip/rk3328-nanopi-r2-rev00.dtb
```



ç¼–è¯‘å®‰è£…åçš„ä½ç½®

dtsi + dts -> dtb

uboot -> dtb -> fdt  -> å†…æ ¸è§£æfdtç”Ÿæˆæ–‡ä»¶ç›®å½•`/sys/firmware/devicetree`

```c
ll /sys/firmware
```



åç¼–è¯‘dtbæ–‡ä»¶

```bash
dtc -I fs -O dts /sys/firmware/devicetree/base > system.dts
```





### åŸºæœ¬è¯­æ³•

```c
/ {
    model = "My Board";
    compatible = "mycompany,myboard";

    chosen {
        bootargs = "console=ttyS0,115200";
    };

    soc {
        compatible = "simple-bus";
        #address-cells = <1>;
        #size-cells = <1>;
        ranges;

        my_peripheral@10000000 {
            compatible = "mycompany,my-device";
            reg = <0x10000000 0x1000>;
            interrupts = <0 25 4>;
            clocks = <&clk 12>;
            status = "okay";
        };
    };
};
```


å…³é”®å±æ€§è¯´æ˜

| å±æ€§å                           | è¯´æ˜                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| `compatible`                     | é©±åŠ¨åŒ¹é…çš„å…³é”®å­—æ®µï¼Œæ ¼å¼ä¸º `"manufacturer,model"`ï¼Œå¯å¤šä¸ª    |
| `reg`                            | å¯„å­˜å™¨åœ°å€å’Œé•¿åº¦ï¼Œå–å†³äºçˆ¶èŠ‚ç‚¹çš„ `#address-cells` / `#size-cells` |
| `interrupts`                     | ä¸­æ–­æè¿°ï¼Œæ ¼å¼ç”± `interrupt-parent` å’Œä¸­æ–­æ§åˆ¶å™¨å†³å®š         |
| `clocks` / `clock-names`         | æ—¶é’Ÿæºå¼•ç”¨ï¼ˆé€šè¿‡ phandleï¼‰                                   |
| `status`                         | `"okay"` è¡¨ç¤ºå¯ç”¨ï¼Œ`"disabled"` è¡¨ç¤ºç¦ç”¨                     |
| `#address-cells` / `#size-cells` | å®šä¹‰å­èŠ‚ç‚¹åœ°å€/å¤§å°å­—æ®µçš„ cell æ•°é‡ï¼ˆé€šå¸¸ä¸º 1 æˆ– 2ï¼‰ã€‚åœ°å€ç”¨2ä¸ª32ä½è¡¨ç¤º64ä½ |



### å¼•ç”¨

- ä½¿ç”¨ `&label` å¼•ç”¨å…¶ä»–èŠ‚ç‚¹ï¼ˆlabel é€šè¿‡ `node: node_name` å£°æ˜ï¼‰
- ä½¿ç”¨ `<&node>` åœ¨å±æ€§ä¸­å¼•ç”¨å…¶ä»–èŠ‚ç‚¹ï¼ˆå¦‚ clocksã€interrupt-parentï¼‰

```dtd
clk: clock-controller@100 {
    compatible = "mycompany,clk";
    reg = <0x100 0x10>;
};

my_device {
    compatible = "mycompany,my-device";
    clocks = <&clk>;
};
```



### åŒ…å«ä¸è¦†ç›–

- ä½¿ç”¨ `#include "file.dtsi"` å¼•å…¥å…¬å…±è®¾å¤‡æ ‘ç‰‡æ®µ
- ä½¿ç”¨ **Device Tree Overlay**ï¼ˆ.dtboï¼‰åŠ¨æ€ä¿®æ”¹è®¾å¤‡æ ‘ï¼ˆå¸¸ç”¨äº FPGAã€åŠ¨æ€åŠ è½½å¤–è®¾ï¼‰



### é©±åŠ¨åŒ¹é…æ–¹å¼

- ä½¿ç”¨ `of_device_id` è¡¨ä¸è®¾å¤‡æ ‘ `compatible` å­—æ®µåŒ¹é…
  - `of`è¡¨ç¤º`open firmware`ï¼Œä¸€èˆ¬ç”¨è¿™ä¸ªå¼€å¤´çš„éƒ½æ˜¯è®¾å¤‡æ ‘ç›¸å…³

1. è‡ªåŠ¨åŒ¹é…å‡½æ•°

```c
static const struct of_device_id my_driver_of_match[] = {
    { .compatible = "mycompany,my-device", },
    { /* sentinel */ }
};
MODULE_DEVICE_TABLE(of, my_driver_of_match);
```

2. `platform_driver`æ³¨å†Œ

```c
static struct platform_driver my_driver = {
    .probe = my_probe,
    .remove = my_remove,
    .driver = {
        .name = "my-device",
        .of_match_table = my_driver_of_match,
        .owner = THIS_MODULE,
    },
};

module_platform_driver(my_driver);
```



### è·å–è®¾å¤‡æ ‘èµ„æº


åœ¨ `probe()` å‡½æ•°ä¸­é€šè¿‡ `struct device_node *np = pdev->dev.of_node;` è·å–èŠ‚ç‚¹ã€‚

- **å¯„å­˜å™¨æ˜ å°„**ï¼š
  
  ```c
  void __iomem *base = devm_platform_ioremap_resource(pdev, 0);
  ```
  æˆ–
  ```c
  struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
  void __iomem *base = devm_ioremap_resource(&pdev->dev, res);
  ```
  
- **ä¸­æ–­è·å–**ï¼š
  ```c
  int irq = platform_get_irq(pdev, 0);
  ```

- **æ—¶é’Ÿè·å–**ï¼š
  ```c
  struct clk *clk = devm_clk_get(&pdev->dev, NULL); // æˆ–æŒ‡å®š clock-name
  clk_prepare_enable(clk);
  ```

- **GPIO è·å–**ï¼š
  
  ```c
  int gpio = devm_gpiod_get(&pdev->dev, "reset", GPIOD_OUT_LOW);
  ```
  
- **å±æ€§è¯»å–**ï¼š
  ```c
  u32 val;
  of_property_read_u32(np, "mycompany,timeout-ms", &val);
  ```



### èµ„æºç®¡ç†

æ¨èä½¿ç”¨ `devm_*`

ä½¿ç”¨ `devm_*` ç³»åˆ—å‡½æ•°è‡ªåŠ¨é‡Šæ”¾èµ„æºï¼ˆå¦‚ `devm_ioremap`, `devm_clk_get`, `devm_gpiod_get`ï¼‰ï¼Œé¿å…å¿˜è®°é‡Šæ”¾ã€‚



### æ³¨æ„äº‹é¡¹

#### 1. è®¾å¤‡æ ‘ç¼–å†™æ³¨æ„äº‹é¡¹

- **compatible å­—æ®µå¿…é¡»å‡†ç¡®**ï¼šæ˜¯é©±åŠ¨åŒ¹é…çš„å”¯ä¸€ä¾æ®ã€‚
- **åœ°å€ç©ºé—´æè¿°ä¸€è‡´**ï¼šç¡®ä¿ `#address-cells` / `#size-cells` ä¸å­èŠ‚ç‚¹ `reg` æ ¼å¼åŒ¹é…ã€‚
- **é¿å…ç¡¬ç¼–ç åœ°å€**ï¼šåº”é€šè¿‡è®¾å¤‡æ ‘ä¼ é€’ï¼Œè€Œä¸æ˜¯åœ¨é©±åŠ¨ä¸­å†™æ­»ã€‚
- **status æ§åˆ¶è®¾å¤‡å¯ç”¨/ç¦ç”¨**ï¼šè°ƒè¯•æ—¶å¯ä¸´æ—¶è®¾ä¸º `disabled`ã€‚
- **ä½¿ç”¨ label ç®€åŒ–å¼•ç”¨**ï¼šæé«˜å¯è¯»æ€§å’Œç»´æŠ¤æ€§ã€‚

#### 2. é©±åŠ¨å¼€å‘æ³¨æ„äº‹é¡¹

- **ä¸è¦åœ¨ probe ä¸­åšè€—æ—¶æ“ä½œ**ï¼šé¿å…é˜»å¡ç³»ç»Ÿå¯åŠ¨ã€‚
- **é”™è¯¯å¤„ç†è¦å®Œæ•´**ï¼šèµ„æºç”³è¯·å¤±è´¥åº” goto æˆ– return é”™è¯¯ç ï¼Œå¹¶é‡Šæ”¾å·²ç”³è¯·èµ„æºã€‚
- **ä½¿ç”¨ devm_ ç³»åˆ—å‡½æ•°**ï¼šå‡å°‘èµ„æºæ³„æ¼é£é™©ã€‚
- **é¿å…å…¨å±€å˜é‡**ï¼šä½¿ç”¨ `platform_set_drvdata()` / `platform_get_drvdata()` ä¿å­˜ç§æœ‰æ•°æ®ã€‚
- **æ”¯æŒ runtime PM**ï¼ˆå¦‚é€‚ç”¨ï¼‰ï¼šé€šè¿‡ `dev_pm_ops` å®ç°ç”µæºç®¡ç†ã€‚

#### 3. è°ƒè¯•æŠ€å·§

- æŸ¥çœ‹è®¾å¤‡æ ‘æ˜¯å¦æ­£ç¡®åŠ è½½ï¼š
  ```bash
  cat /proc/device-tree/...      # åŸå§‹è®¾å¤‡æ ‘
  dtc -I fs -O dts /proc/device-tree > system.dts  # åç¼–è¯‘æŸ¥çœ‹
  ```
- æŸ¥çœ‹ platform device æ˜¯å¦æ³¨å†Œï¼š
  ```bash
  ls /sys/bus/platform/devices/
  ```
- æŸ¥çœ‹é©±åŠ¨æ˜¯å¦åŠ è½½ï¼š
  ```bash
  dmesg | grep my-device
  ```

#### 4. å…¼å®¹æ€§ä¸å¯ç§»æ¤æ€§

- é©±åŠ¨åº”å°½é‡é€šè¿‡è®¾å¤‡æ ‘è·å–æ‰€æœ‰ç¡¬ä»¶ä¿¡æ¯ï¼Œé¿å…æ¿çº§ä»£ç ï¼ˆboard fileï¼‰ã€‚
- å¤šä¸ª compatible å­—ç¬¦ä¸²å¯ç”¨äºå…¼å®¹ä¸åŒç‰ˆæœ¬ç¡¬ä»¶ï¼š
  ```c
  { .compatible = "mycompany,my-device-v2", .data = &v2_data },
  { .compatible = "mycompany,my-device", .data = &v1_data },
  ```
  åœ¨ probe ä¸­é€šè¿‡ `of_device_get_match_data()` è·å–ç§æœ‰æ•°æ®ã€‚





### æ‰‹åŠ¨è·å–è®¾å¤‡æ ‘èµ„æº

```c
#include <linux/module.h>
#include <linux/init.h>
#include <linux/of.h> 														
#include <linux/of_gpio.h> 														
#include <linux/gpio.h>															
#include <dt-bindings/gpio/gpio.h>	

/*
	node3399 {
		compatible = "xyd_3399";
		reg = <0xFF76037c 0x4
			0xFF77e000 0x4
			0xFF780004 0x4
			0xFF780000 0x4
		>;
		testprop,mytest;
		test_list_string = "red fish","green fish", "blue fish";
		gpios = <&gpio1 4 GPIO_ACTIVE_HIGH>;
		interrupt-parent = <&gpio2>;
		interrupts = <7 IRQ_TYPE_EDGE_BOTH>; // ä¸Šå‡æ²¿å’Œä¸‹é™æ²¿è§¦å‘
		key-irq-gpio = <&gpio2 7 IRQ_TYPE_EDGE_BOTH>; // GPIO2_A7  71
		xyd-led3 { //LED3
			gpios = <&gpio2 9 GPIO_ACTIVE_LOW>; //73
			label = "led3";
		};
	};

*/

static int __init hello_init(void) 
{
	int i;
	int ret;
    int count;
	//èŠ‚ç‚¹å¯¹è±¡
	struct device_node *np = NULL, *child_np = NULL;
	//é”®å¯¹è±¡
	struct property *prop = NULL;
	u32 regdata[8];
	int gpiono;
	enum of_gpio_flags flags;

	//1.é€šè¿‡ç»å¯¹è·¯å¾„è·å¾—è®¾å¤‡èŠ‚ç‚¹å¯¹è±¡
	np = of_find_node_by_path("/xydnode3399");
	if (np) {
		printk("name=%s\n", np->name);
		printk("full name=%s\n", np->full_name);
	} else {
		printk("of_find_node_by_path fail\n");
		return -EFAULT;
	}

	//2.è·å–èŠ‚ç‚¹ä¸‹çš„å±æ€§å¯¹è±¡
	prop = of_find_property(np, "compatible", NULL);
	if (prop) {
		printk("name=%s\n", prop->name);
		printk("value=%s\n", (char *)prop->value);
	} else {
		printk("of_find_property fail\n");
		return -EFAULT;
	}
	//3.è·å–èŠ‚ç‚¹
	prop = of_find_property(np, "testprop,mytest", NULL);
	if (prop) {
		printk("name=%s\n", prop->name);
	} else {
		printk("of_find_property fail\n");
		return -EFAULT;
	}
    //4.è·å–å­—ç¬¦ä¸²åˆ—è¡¨
	if((count = of_property_count_strings(np, "test_list_string")))
	{
		const char *test_list_string[count];
		for(i = 0; i < count; i++) {
			if (of_property_read_string_index(np, "test_list_string", i, &test_list_string[i]) == 0) {
				printk("test_list_string[%d]: %s\n", i, test_list_string[i]);
			}
		}
	}
	//5.è·å–regé”®å€¼ï¼›æ•°ç»„
	ret = of_property_read_u32_array(np, "reg", regdata, ARRAY_SIZE(regdata));
	if (!ret) {
		for (i = 0; i < ARRAY_SIZE(regdata); i++) {
			printk("regdata[%d]=0x%x\n", i , regdata[i]);
		}
	} else {
		printk("of_property_read_u32_array fail\n");
		return -EINVAL;
	}
	//6.è·å–gpioå¼•è„šå·
	gpiono = of_get_named_gpio_flags(np, "gpios", 0, &flags);
	if (gpio_is_valid(gpiono)) {
		printk("gpiono=%d\n", gpiono);
		printk("flags==GPIO_ACTIVE_HIGH: %d\n", flags==GPIO_ACTIVE_HIGH);
	} else {
		printk("of_get_named_gpio_flags fail\n");
		return -EINVAL;
	}
	//7.è·å–gpioå¼•è„šå·
	gpiono = of_get_named_gpio_flags(np, "key-irq-gpio", 0, &flags);
	if (gpio_is_valid(gpiono)) {
		printk("gpiono=%d\n", gpiono);
		printk("flags==IRQ_TYPE_EDGE_BOTH: %d\n", flags==IRQ_TYPE_EDGE_BOTH);
	} else {
		printk("of_get_named_gpio_flags fail\n");
		return -EINVAL;
	}

	//è§£æå­èŠ‚ç‚¹
	
	//é€šè¿‡ç»å¯¹è·¯å¾„è·å¾—è®¾å¤‡èŠ‚ç‚¹å¯¹è±¡
#if 0
	child_np = of_find_node_by_path("/node3399/xyd-led3");
#else
	child_np = of_get_child_by_name(np, "xyd-led3");
#endif


	if (child_np) {
		printk("name=%s\n", child_np->name);
		printk("full name=%s\n", child_np->full_name);
		gpiono = of_get_named_gpio_flags(child_np, "gpios", 0, &flags);
		if (gpio_is_valid(gpiono)) {
			printk("gpiono=%d\n", gpiono);
			
			printk("flags==GPIO_ACTIVE_LOW: %d\n", flags==GPIO_ACTIVE_LOW);
		} else {
			printk("of_get_named_gpio_flags fail\n");
			return -EINVAL;
		}
		
	} else {
		printk("of_find_node_by_path fail\n");
		return -EFAULT;
	}

	printk("call %s() @ %d\n", __func__, __LINE__);
	return 0;
}

static void __exit hello_exit(void) 
{
	printk("call %s() @ %d\n", __FUNCTION__, __LINE__);
}


//å…¥å£
module_init(hello_init);
//å‡ºå£
module_exit(hello_exit);
MODULE_LICENSE("GPL"); 
```



- **è·å–GPIOå¼•è„š**

è®¾å¤‡æ ‘èŠ‚ç‚¹

```dtd
myled_ctrl {	
    status = "okay";
    compatible = "rk3399_led2_green";
    gpio_led = <&gpio1 23 GPIO_ACTIVE_HIGH>; // GPIO1_C7 
};	
```

ä»£ç 

```c
//è·å–åŒ¹é…çš„device_nodeå¯¹è±¡
struct device_node *led_ctrl_node = pdev->dev.of_node;
//æ‹¿åˆ°å¼•è„š
// ä½¿ç”¨ of_get_named_gpio(button_ctrl_node, "gpios", 0);æˆ–ä¸‹åˆ—å‡½æ•°
gpio_led = of_get_named_gpio_flags(led_ctrl_node, "gpio_led", 0, &flags);
if (!gpio_is_valid(gpio_led)) {
    printk("of_get_named_gpio_flags fail\n");
    return -EINVAL;
} 
printk("gpio_led=%d\n", gpio_led);
printk("flags==GPIO_ACTIVE_HIGH: %d\n", flags==GPIO_ACTIVE_HIGH);
```










### ç°ä»£è®¾å¤‡æ ‘åŒ¹é…æ–¹å¼ï¼ˆä¸»æµï¼‰

è®¾å¤‡ä¿¡æ¯ç”±è®¾å¤‡æ ‘æè¿°ï¼Œå†…æ ¸åœ¨å¯åŠ¨æ—¶è‡ªåŠ¨è§£æå¹¶æ³¨å†Œ `platform_device`ã€‚é©±åŠ¨é€šè¿‡ `of_match_table` è‡ªåŠ¨åŒ¹é…ã€‚

```c
#include <linux/platform_device.h>
#include <linux/of.h>
#include <linux/of_address.h>
#include <linux/of_irq.h>

static int my_probe(struct platform_device *pdev)
{
    struct resource *res;
    void __iomem *base;
    int irq;

    // è·å–å¯„å­˜å™¨èµ„æº
    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
    if (!res)
        return -EINVAL;

    base = devm_ioremap_resource(&pdev->dev, res);
    if (IS_ERR(base))
        return PTR_ERR(base);

    // è·å–ä¸­æ–­
    irq = platform_get_irq(pdev, 0);
    if (irq < 0)
        return irq;

    // å…¶ä»–åˆå§‹åŒ–ï¼šæ—¶é’Ÿã€å¤ä½ã€DMA ç­‰
    // ...

    dev_info(&pdev->dev, "Device probed successfully\n");
    return 0;
}

static int my_remove(struct platform_device *pdev)
{
    // æ‰§è¡Œæ¸…ç†ï¼ˆè‹¥æœªä½¿ç”¨ devm_ ç³»åˆ—å‡½æ•°ï¼‰
    return 0;
}

static const struct of_device_id my_of_match[] = {
    { .compatible = "vendor,my-device" },
    { }
};
MODULE_DEVICE_TABLE(of, my_of_match);

static struct platform_driver my_driver = {
    .probe = my_probe,
    .remove = my_remove,
    .driver = {
        .name = "my-device",
        .of_match_table = my_of_match,
        .owner = THIS_MODULE,
    },
};

module_platform_driver(my_driver); // è‡ªåŠ¨æ³¨å†Œ/æ³¨é”€
MODULE_LICENSE("GPL");
```



### è®¾å¤‡é©±åŠ¨åŒ¹é…è§„åˆ™

`platform.c`æ¡†æ¶æºç 

```c
static int platform_match(struct device *dev, struct device_driver *drv)
{
	struct platform_device *pdev = to_platform_device(dev);
	struct platform_driver *pdrv = to_platform_driver(drv);

	/* When driver_override is set, only bind to the matching driver */
	if (pdev->driver_override)
		return !strcmp(pdev->driver_override, drv->name);

	/* Attempt an OF style match first */    //1.è®¾å¤‡æ ‘of_match_tableåŒ¹é…
	if (of_driver_match_device(dev, drv))
		return 1;

	/* Then try ACPI style match */
	if (acpi_driver_match_device(dev, drv))
		return 1;

	/* Then try to match against the id table */     //2.å¹³å°æ€»çº¿é©±åŠ¨id_tableåˆ—è¡¨åŒ¹é…
	if (pdrv->id_table)
		return platform_match_id(pdrv->id_table, pdev) != NULL;

	/* fall-back to driver name match */            //3.å¹³å°æ€»çº¿é©±åŠ¨ååŒ¹é…
	return (strcmp(pdev->name, drv->name) == 0);
}
```



### è·å–ä¸­æ–­é…ç½®

**æ–¹æ³•1**

è®¾å¤‡æ ‘ä¸»æ–‡ä»¶

```c
pinctrl: pinctrl {
    compatible = "rockchip,rk3399-pinctrl";
    rockchip,grf = <&grf>;
    rockchip,pmu = <&pmugrf>;
    #address-cells = <2>;
    #size-cells = <2>;
    ranges;

    gpio0: gpio0@ff720000 {
        compatible = "rockchip,gpio-bank";
        reg = <0x0 0xff720000 0x0 0x100>;
        clocks = <&pmucru PCLK_GPIO0_PMU>;
        interrupts = <GIC_SPI 14 IRQ_TYPE_LEVEL_HIGH 0>;

        gpio-controller;		//å£°æ˜GPIOæ§åˆ¶å™¨
        #gpio-cells = <0x2>;

        interrupt-controller;      //å£°æ˜ä¸­æ–­æ§åˆ¶å™¨
        #interrupt-cells = <0x2>;
    };
};
```

è‡ªå®šä¹‰è®¾å¤‡èŠ‚ç‚¹

```c
pwr_button {				
    compatible = "rk3399,power-button"; 			
    interrupt-parent = <&gpio0>;			//å¯¹åº”çš„ä¸Šçº§ä¸­æ–­æ§åˆ¶å™¨æ˜¯ gpio0
    interrupts = <5 IRQ_TYPE_EDGE_BOTH>; 	//å¼•è„šå· è§¦å‘æ–¹å¼ GPIO0_A5
};
```

ä»£ç è·å–ä¸­æ–­èµ„æº

```c
static int irqno;   //ä¸­æ–­å·

//ä¸­æ–­å¤„ç†å‡½æ•°
static irqreturn_t button_handler(int irqno, void *dev)
{
	printk("call %s() @ %d\n", __func__, __LINE__);
	return IRQ_HANDLED;
}

//å½“å¹³å°è®¾å¤‡å’Œå¹³å°é©±åŠ¨åŒ¹é…æ—¶ä¼šè°ƒç”¨probeå‡½æ•°, å‚æ•°pdevå°±æ˜¯åŒ¹é…ä¸Šå¹³å°è®¾å¤‡å¯¹è±¡
static int button_probe(struct platform_device *pdev)
{
	
	int ret;
	int trigger_type;
	//1.ä»platform_deviceçš„è®¾å¤‡æ ‘èŠ‚ç‚¹ä¸­æ‹¿åˆ°ä¸­æ–­å·
	irqno = of_irq_get(pdev->dev.of_node, 0);
	if (irqno <= 0) {
		printk("of_irq_get fail\n");
		return -EFAULT;
	}
	printk("irqno=%d\n", irqno);
    
	//2.ä½¿ç”¨ä¸­æ–­å·æ‹¿åˆ°è§¦å‘ç±»å‹
	trigger_type = irq_get_trigger_type(irqno);
	if (trigger_type == IRQ_TYPE_EDGE_BOTH) {
		printk("åŒè¾¹æ²¿è§¦å‘\n");
	}
	
	//3.ç”³è¯·ä¸­æ–­æ³¨å†Œä¸­æ–­å‡½æ•°
	ret = request_irq(irqno, button_handler, trigger_type, "power_key_int", NULL);
	if (ret) {
		printk("request_irq fail\n");
		return -EFAULT;
	}

	printk("call %s() @ %d\n", __func__, __LINE__);
	return 0;
}

//å½“å¹³å°è®¾å¤‡å’Œå¹³å°é©±åŠ¨åˆ†ç¦»æ—¶ä¼šè°ƒç”¨removeå‡½æ•°
static int button_remove(struct platform_device *pdev)
{
    //é‡Šæ”¾ä¸­æ–­
	free_irq(irqno, NULL);
	printk("call %s() @ %d\n", __func__, __LINE__);
	return 0;

}
```

**æ–¹æ³•2**

```c
//ä½¿ç”¨platform_get_resourceå‡½æ•°æ‹¿åˆ°å¹³å°è®¾å¤‡ä¸­çš„resourceå±æ€§ï¼Œä»resourceä¸­å–ä¸­æ–­å·
struct resource *irq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
irqno = irq_res->start;
```

**æ–¹æ³•3**

```c
//ç›´æ¥ä»å¹³å°è®¾å¤‡å¯¹è±¡ä¸­æ‹¿
irqno = platform_get_irq(pdev, 0);
```







## åä¸‰ã€PINCTLå­ç³»ç»Ÿ



**æ ¸å¿ƒå®šä½ä¸èŒè´£**

| å­ç³»ç»Ÿ      | å®šä½                   | ä¸»è¦èŒè´£                                                     |
| ----------- | ---------------------- | ------------------------------------------------------------ |
| **pinctrl** | **å¼•è„šæ§åˆ¶å™¨å­ç³»ç»Ÿ**   | ç®¡ç†å¼•è„šçš„**å¤ç”¨åŠŸèƒ½ï¼ˆmuxï¼‰** å’Œ **ç”µæ°”å±æ€§é…ç½®ï¼ˆconfigï¼‰**<br>ä¾‹å¦‚ï¼šå°†ç‰©ç†å¼•è„šé…ç½®ä¸º UART-TXã€I2C-SCL æˆ– GPIOï¼›è®¾ç½®ä¸Šæ‹‰ã€é©±åŠ¨å¼ºåº¦ç­‰ |
| **GPIO**    | **é€šç”¨è¾“å…¥è¾“å‡ºå­ç³»ç»Ÿ** | ç®¡ç†å¼•è„šä½œä¸º **GPIOï¼ˆé€šç”¨è¾“å…¥/è¾“å‡ºï¼‰åŠŸèƒ½** æ—¶çš„è¡Œä¸º<br>ä¾‹å¦‚ï¼šè¯»å– GPIO ç”µå¹³ã€è®¾ç½®è¾“å‡ºé«˜ä½ã€ç”³è¯·ä¸­æ–­ç­‰ |

> âœ… **ç®€å•ç±»æ¯”**ï¼š  
>
> - **pinctrl** å†³å®šâ€œè¿™ä¸ªå¼•è„š**æ˜¯ä»€ä¹ˆè§’è‰²**â€ï¼ˆæ˜¯ UART è¿˜æ˜¯ GPIOï¼‰  
> - **GPIO** å†³å®šâ€œå½“å®ƒæ˜¯ GPIO æ—¶ï¼Œ**æ€ä¹ˆæ“ä½œå®ƒ**â€ï¼ˆè¯»ã€å†™ã€ä¸­æ–­ï¼‰



- **pinctrl æ˜¯åº•å±‚**ï¼šå¿…é¡»å…ˆå°†å¼•è„š**å¤ç”¨ä¸º GPIO åŠŸèƒ½**ï¼ˆå¦‚ `RK_FUNC_0`ï¼‰ï¼ŒGPIO å­ç³»ç»Ÿæ‰èƒ½æ“ä½œå®ƒã€‚
- **GPIO ä¾èµ– pinctrl**ï¼šå¦‚æœæ²¡æœ‰ pinctrlï¼ˆæˆ–å¼•è„šæœªè®¾ä¸º GPIOï¼‰ï¼Œ`gpio_request()` ä¼šå¤±è´¥ã€‚



### pinctrlï¼šæè¿°â€œå¼•è„šè¯¥æ€ä¹ˆé…â€

```c
pinctrl_uart1: uart1-pins {
    rockchip,pins = <
        2 11 RK_FUNC_1 &pcfg_pull_none   /* TX as UART1 */
        2 12 RK_FUNC_1 &pcfg_pull_up     /* RX as UART1 */
    >;
};

uart1: serial@ff190000 {
    pinctrl-names = "default";
    pinctrl-0 = <&pinctrl_uart1>;   // åªç”¨ pinctrlï¼Œä¸æ¶‰åŠ GPIO
};
```

### æè¿°â€œä½œä¸º GPIO æ€ä¹ˆç”¨â€

```c
my_led {
    gpios = <&gpio2 9 GPIO_ACTIVE_LOW>;  // ä½¿ç”¨ GPIO2_9
    // æ³¨æ„ï¼šè¿™ä¸ªå¼•è„šå¿…é¡»åœ¨ pinctrl ä¸­é…ç½®ä¸º GPIO åŠŸèƒ½ï¼
};
&pinctrl {			
    key1_button {
        button_k1_gpio:button_k1_gpio {
            rockchip,pins = <1 1 RK_FUNC_GPIO &pcfg_pull_up>;  //gpio1_A1 å¼•è„šåŠŸèƒ½é…ç½®ä¸ºGPIO å†…éƒ¨ä¸Šæ‹‰ 
        };
    };
};
```

âš ï¸ **å…³é”®**ï¼š`gpios = <&gpio2 9 ...>` ä¸­çš„ `gpio2` æ˜¯ä¸€ä¸ª **GPIO controller èŠ‚ç‚¹**ï¼Œè€Œè¯¥èŠ‚ç‚¹å†…éƒ¨é€šå¸¸ä¼šå¼•ç”¨ pinctrlï¼š

> ```c
> gpio2: gpio2@ff720000 {
>     compatible = "rockchip,rk3399-gpio";
>     gpio-controller;			// å£°æ˜ä¸ºgpioæ§åˆ¶å™¨
>     #gpio-cells = <2>;
>     gpio-ranges = <&pinctrl 0 0 32>;  // å‘Šè¯‰ GPIO å­ç³»ç»Ÿï¼šè¿™32ä¸ªGPIOç”±pinctrlç®¡ç†
> };
> ```



**æ¡ˆä¾‹1**ï¼šé…ç½®å¼•è„šçš„å·¥ä½œæ–¹å¼

```dtd
&pinctrl {
	key1_button {
		button_k1_gpio:button_k1_gpio {  //å®šä¹‰ä¸‰ä¸ªæŒ‰é’®ä¸ºä¸Šæ‹‰è¾“å‡º
			rockchip,pins = <1 1 RK_FUNC_GPIO &pcfg_pull_up>,
							<1 3 RK_FUNC_GPIO &pcfg_pull_up>,
							<1 4 RK_FUNC_GPIO &pcfg_pull_up>;
		};
	};
};
```

**æ¡ˆä¾‹2ï¼š**åŒæ—¶ä½¿ç”¨ä¸‰ä¸ªå¼•è„šçš„ä¸­æ–­

```dtd
key1_button {					
    compatible = "rk3399,key1-button";
    gpios = <&gpio1 1 IRQ_TYPE_EDGE_BOTH>; //GPIO1_A1
    pinctrl-names = "default";
    pinctrl-0 = <&button_k1_gpio>;
};
//add k1								
key1_button {								
    compatible = "rk3399,key1-button";								
    gpios = <&gpio1 1 IRQ_TYPE_EDGE_BOTH>; //GPIO1_A1								
    gpios3 = <&gpio1 3 IRQ_TYPE_EDGE_BOTH>; //GPIO1_A3								
    gpios4 = <&gpio1 4 IRQ_TYPE_EDGE_BOTH>; //GPIO1_A4								
    pinctrl-names = "default";								
    pinctrl-0 = <&button_k1_gpio>;								
};
```

ä»£ç 

```c
static int button_probe(struct platform_device *pdev)
{
	enum of_gpio_flags  flags;
	int ret;
	//1. è·å–åŒ¹é…çš„è®¾å¤‡æ ‘èŠ‚ç‚¹å¯¹è±¡
	struct device_node *button_ctrl_node = pdev->dev.of_node;
	gpio_button = of_get_named_gpio_flags(button_ctrl_node, "gpios", 0, &flags);
	if (gpio_is_valid(gpio_button)) {
		printk("gpio_button=%d\n", gpio_button);
		printk("flags==GPIO_ACTIVE_LOW:%d\n", flags==GPIO_ACTIVE_LOW);
	} else {
		printk("of_get_named_gpio_flags fail\n");
		return -EFAULT;
	}
	//è·å–ä¸­æ–­å·
	irqno1 = gpio_to_irq(gpio_button);
	printk("k1 irqno = %d\n", irqno1);
	//ç”³è¯·ä¸­æ–­
	ret = request_irq(irqno1, button_handler, IRQ_TYPE_EDGE_BOTH, "k1_key_xyd", "k1");
	if (ret) {
		printk("request_irq fail\n");
		return -EFAULT;
	}

	gpio_button = of_get_named_gpio_flags(button_ctrl_node, "gpios3", 0, &flags);
	if (gpio_is_valid(gpio_button)) {
		printk("gpio_button=%d\n", gpio_button);
		printk("flags==GPIO_ACTIVE_LOW:%d\n", flags==GPIO_ACTIVE_LOW);
	} else {
		printk("of_get_named_gpio_flags fail\n");
		return -EFAULT;
	}
	//è·å–ä¸­æ–­å·
	irqno2 = gpio_to_irq(gpio_button);
	printk("k2 irqno = %d\n", irqno2);
	//ç”³è¯·ä¸­æ–­
	ret = request_irq(irqno2, button_handler, IRQ_TYPE_EDGE_BOTH, "k2_key_xyd", "k2");
	if (ret) {
		printk("request_irq fail\n");
		return -EFAULT;
	}

	gpio_button = of_get_named_gpio_flags(button_ctrl_node, "gpios4", 0, &flags);
	if (gpio_is_valid(gpio_button)) {
		printk("gpio_button=%d\n", gpio_button);
		printk("flags==GPIO_ACTIVE_LOW:%d\n", flags==GPIO_ACTIVE_LOW);
	} else {
		printk("of_get_named_gpio_flags fail\n");
		return -EFAULT;
	}
	//è·å–ä¸­æ–­å·
	irqno3 = gpio_to_irq(gpio_button);
	printk("k3 irqno = %d\n", irqno3);
	//ç”³è¯·ä¸­æ–­
	ret = request_irq(irqno3, button_handler, IRQ_TYPE_EDGE_BOTH, "k3_key_xyd", "k3");
	if (ret) {
		printk("request_irq fail\n");
		return -EFAULT;
	}

	printk("<kernel> call %s()\n", __func__);
	return 0;
}
static int button_remove(struct platform_device *pdev)
{
	free_irq(irqno3,"k3");
	free_irq(irqno2,"k2");
	free_irq(irqno1,"k1");
	printk("<kernel> call %s()\n", __func__);
	return 0;
}
```





## åå››ã€å±æ€§æ–‡ä»¶æ“ä½œ



**è®¾å¤‡å±æ€§æ–‡ä»¶**

---

é€šè¿‡å±æ€§æ–‡ä»¶é©±åŠ¨å¯ä»¥ç”Ÿæˆä¸€ä¸ªé¢å¤–çš„æ™®é€šæ–‡ä»¶è¿›è¡Œé©±åŠ¨æ–‡ä»¶çš„è¯»å†™ï¼Œæ–¹ä¾¿æ²¡æœ‰ç³»ç»Ÿè°ƒç”¨æ—¶æ“ä½œé©±åŠ¨ï¼ˆreadï¼Œwriteï¼‰

ç›´æ¥ä½¿ç”¨`cat`æˆ–`echo`å¯è¿›è¡Œé©±åŠ¨æ§åˆ¶æ“ä½œ

å®ç°å±æ€§æ–‡ä»¶çš„æ ¸å¿ƒæœºåˆ¶æ˜¯ **`struct device_attribute`** å’Œ **`struct driver_attribute`**ï¼Œåˆ†åˆ«å¯¹åº” **è®¾å¤‡å±æ€§** å’Œ **é©±åŠ¨å±æ€§**ã€‚

**æ ¸å¿ƒç»“æ„ä½“**

```c
struct device_attribute {
	struct attribute	attr;
	ssize_t (*show)(struct device *dev, struct device_attribute *attr,
			char *buf);
	ssize_t (*store)(struct device *dev, struct device_attribute *attr,
			 const char *buf, size_t count);
};
```



### æ¡ˆä¾‹å®ç°

```c
#include <linux/module.h>
#include <linux/init.h>
#include <linux/platform_device.h>
#include <linux/of.h> 												
#include <linux/of_gpio.h> 												
#include <linux/gpio.h>															
#include <dt-bindings/gpio/gpio.h>	


static int gpio_led;
static int gpio_value;

ssize_t gpio_led_show(struct device *dev, struct device_attribute *attr, 	char *buf)
{
	printk("call %s() @ %d\n", __func__, __LINE__);
	return sprintf(buf, "led %d level\n", gpio_get_value(gpio_led));
}

ssize_t gpio_led_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
{
	int ret, value;
	ret = kstrtoint(buf, 10, &value); //å­—ç¬¦ä¸²è½¬10è¿›åˆ¶æ•´æ•°
	if (ret) {
		printk("kstrtoint fail\n");
		return -EFAULT;
	}

	printk("call %s() @ %d  value=%d\n", __func__, __LINE__, value);

	if (value == 1) {
		gpio_direction_output(gpio_led, gpio_value);
		printk("led on\n");
	} else if(value == 0) {
		gpio_direction_output(gpio_led, !gpio_value);
		printk("led off\n");
	} else {
		printk("i only support 0 or 1 ctrl led\n");
	}

	return count; //ä¸èƒ½è¿”å›return 
}


//1.åˆ›å»ºè®¾å¤‡å±æ€§å¯¹è±¡å¹¶åˆå§‹åŒ–
//åˆ›å»ºstruct device_attributeå¯¹è±¡dev_attr_gpio_led
static DEVICE_ATTR(gpio_led, 0664, gpio_led_show, gpio_led_store);


//å¹³å°æ€»çº¿probeå‡½æ•°
static int led_probe(struct platform_device *pdev)
{
	enum of_gpio_flags flags;
	
	struct device_node *led_ctrl_node = pdev->dev.of_node;
	gpio_led = of_get_named_gpio_flags(led_ctrl_node, "gpio_led", 0, &flags);
	if (gpio_is_valid(gpio_led)) {
		printk("gpio_led=%d\n", gpio_led);
		printk("flags==GPIO_ACTIVE_HIGH: %d\n", flags==GPIO_ACTIVE_HIGH);
	} else {
		printk("of_get_named_gpio_flags fail\n");
		return -EINVAL;
	}

	gpio_value = (flags==GPIO_ACTIVE_HIGH );
	gpio_request(gpio_led, "led2_green");
	gpio_direction_output(gpio_led, !gpio_value);
	gpio_free(gpio_led);

	//2.åˆ›å»ºgpio_ledå±æ€§æ–‡ä»¶	ç±»ä¼¼åˆ›å»ºè®¾å¤‡æ–‡ä»¶
	device_create_file(&pdev->dev, &dev_attr_gpio_led);
	
	printk("call %s() @ %d\n", __func__, __LINE__);
	return 0;
}

static int led_remove(struct platform_device *pdev)
{
	//é”€æ¯gpio_ledå±æ€§æ–‡ä»¶
	device_remove_file(&pdev->dev, &dev_attr_gpio_led);
	printk("call %s() @ %d\n", __func__, __LINE__);
	return 0;
}

static const struct of_device_id led_ctrl_match_table[] = {
	{ .compatible = "rk3399_led2_green", }, //å’Œè®¾å¤‡èŠ‚ç‚¹compatibleå±æ€§åŒ¹é…
	{}
};

struct platform_driver led_driver = {
	.probe	= led_probe,
	.remove	= led_remove,
	.driver	= {
		.name	= "rk_led", //å¹³å°é©±åŠ¨åç§°,åˆæ˜¯åŒ¹é…æ¡ä»¶
		.of_match_table = led_ctrl_match_table,
	},
};

static int __init drv_mod_init(void) 
{
	printk("call %s() @ %d\n", __func__, __LINE__);
	return platform_driver_register(&led_driver);
}

static void __exit drv_mod_exit(void) 
{
	printk("call %s() @ %d\n", __FUNCTION__, __LINE__);
	platform_driver_unregister(&led_driver);
}

module_init(drv_mod_init);
module_exit(drv_mod_exit);
MODULE_LICENSE("GPL"); 

```



### å…³é”®å‡½æ•°

#### DEVICE_ATTR

åˆ›å»ºä¸€ä¸ªæ‹¼æ¥çš„`struct device_attribute`å¯¹è±¡

```c
//device.h
//å‚æ•°1ï¼šåç§°æ‹¼æ¥
//å‚æ•°2ï¼šæ–‡ä»¶æƒé™ç 
//å‚æ•°3ï¼šshowå›è°ƒå‡½æ•°
//å‚æ•°4ï¼šstoreå›è°ƒå‡½æ•°
static DEVICE_ATTR(gpio_led, 0664, gpio_led_show, gpio_led_store);
```

å®å±•å¼€

```c
#define DEVICE_ATTR(_name, _mode, _show, _store) \
	struct device_attribute dev_attr_##_name = __ATTR(_name, _mode, _show, _store)
```

```c
static struct device_attribute dev_attr_gpio_led = {
    .attr = {.name = "gpio_led", .mode = 0644},
    .show = gpio_led_show,
    .store = gpio_led_store,
};
```

**æ³¨å†Œ/æ³¨é”€**å±æ€§åœ¨ `probe()` å’Œ `remove()` ä¸­



#### device_create_file

åˆ›å»ºå±æ€§æ–‡ä»¶

```c
device_create_file(&pdev->dev, &dev_attr_gpio_led);
```

#### device_remove_file

é”€æ¯å±æ€§æ–‡ä»¶

```c
device_remove_file(&pdev->dev, &dev_attr_gpio_led);
```



### ç”¨æˆ·ç©ºé—´è®¿é—®

```bash
# å†™å…¥
echo 42 > /sys/devices/platform/my-device/my_value
# è¯»å–
cat /sys/devices/platform/my-device/my_value
```





**é©±åŠ¨å±æ€§æ–‡ä»¶**

---



é€‚ç”¨äº**é©±åŠ¨å…¨å±€é…ç½®**ï¼ˆä¸ç»‘å®šå…·ä½“è®¾å¤‡ï¼‰ã€‚

1. **å®šä¹‰é©±åŠ¨å±æ€§**

```c
static ssize_t debug_level_show(struct device_driver *drv, char *buf)
{
    return sprintf(buf, "%d\n", global_debug_level);
}

static ssize_t debug_level_store(struct device_driver *drv,
                                 const char *buf, size_t count)
{
    return kstrtoint(buf, 10, &global_debug_level) ? -EINVAL : count;
}

static DRIVER_ATTR_RW(debug_level);
```



2. **æ³¨å†Œåˆ° platform_driver**

```c
static struct platform_driver my_driver = {
    .probe = my_probe,
    .remove = my_remove,
    .driver = {
        .name = "my-device",
        .of_match_table = my_of_match,
    },
};

// åœ¨æ¨¡å—åˆå§‹åŒ–æ—¶åˆ›å»º
static int __init my_init(void)
{
    int ret = platform_driver_register(&my_driver);
    if (ret)
        return ret;

    // åˆ›å»ºé©±åŠ¨çº§å±æ€§
    ret = driver_create_file(&my_driver.driver, &driver_attr_debug_level);
    if (ret)
        platform_driver_unregister(&my_driver);
    return ret;
}

static void __exit my_exit(void)
{
    driver_remove_file(&my_driver.driver, &driver_attr_debug_level);
    platform_driver_unregister(&my_driver);
}
```



3. **ç”¨æˆ·ç©ºé—´è®¿é—®**

```c
cat /sys/bus/platform/drivers/my-device/debug_level
echo 2 > /sys/bus/platform/drivers/my-device/debug_level
```



### é«˜çº§ç”¨æ³•ï¼šå¤šä¸ªå±æ€§ & è‡ªåŠ¨åˆ›å»º

```c
static struct attribute *my_attrs[] = {
    &dev_attr_my_value.attr,
    &dev_attr_status.attr,
    NULL,
};

static const struct attribute_group my_attr_group = {
    .attrs = my_attrs,
};

// åœ¨ probe ä¸­ï¼š
sysfs_create_group(&pdev->dev.kobj, &my_attr_group);

// åœ¨ remove ä¸­ï¼š
sysfs_remove_group(&pdev->dev.kobj, &my_attr_group);
```





## åäº”ã€è¾“å…¥å­ç³»ç»Ÿ

Linux è¾“å…¥å­ç³»ç»Ÿï¼ˆInput Subsystemï¼‰æ˜¯å†…æ ¸ä¸­ç”¨äº**ç»Ÿä¸€ç®¡ç†å„ç±»è¾“å…¥è®¾å¤‡**ï¼ˆå¦‚æŒ‰é”®ã€é¼ æ ‡ã€è§¦æ‘¸å±ã€æ¸¸æˆæ‰‹æŸ„ã€åŠ é€Ÿåº¦è®¡ç­‰ï¼‰çš„æ ¸å¿ƒæ¡†æ¶ã€‚å®ƒå°†ç¡¬ä»¶å·®å¼‚æŠ½è±¡åŒ–ï¼Œä¸ºç”¨æˆ·ç©ºé—´æä¾›ç»Ÿä¸€çš„äº‹ä»¶æ¥å£ï¼ˆ`/dev/input/eventX`ï¼‰ï¼Œå¹¶æ”¯æŒå†…æ ¸ç©ºé—´äº‹ä»¶ä¸ŠæŠ¥ã€‚

### ä¸‰å¤§ç»„ä»¶

1. **è®¾å¤‡é©±åŠ¨å±‚**ï¼ˆDriverï¼‰  
   - è´Ÿè´£ä¸ç¡¬ä»¶äº¤äº’ï¼ˆè¯»å– GPIOã€I2Cã€SPI ç­‰ï¼‰
   - è°ƒç”¨ Input Core API ä¸ŠæŠ¥äº‹ä»¶
2. **è¾“å…¥æ ¸å¿ƒå±‚**ï¼ˆInput Coreï¼‰  
   - ä½äº `drivers/input/`ï¼Œæä¾›é€šç”¨æ¥å£ï¼ˆ`input_allocate_device`, `input_event` ç­‰ï¼‰
   - ç®¡ç†è®¾å¤‡æ³¨å†Œã€äº‹ä»¶åˆ†å‘ã€è®¾å¤‡å·åˆ†é…
3. **äº‹ä»¶å¤„ç†å±‚**ï¼ˆEvent Handlerï¼‰  
   - å¦‚ `evdev`ï¼ˆç”Ÿæˆ `/dev/input/eventX`ï¼‰
   - å¦‚ `mousedev`ï¼ˆå…¼å®¹è€å¼é¼ æ ‡ï¼‰ã€`joydev`ï¼ˆæ¸¸æˆæ‰‹æŸ„ï¼‰

> âœ… **ç”¨æˆ·ç©ºé—´é€šè¿‡ `/dev/input/eventX` ä»¥ç»Ÿä¸€æ ¼å¼è¯»å–äº‹ä»¶**ï¼Œæ— éœ€å…³å¿ƒåº•å±‚æ˜¯ GPIO æŒ‰é”®è¿˜æ˜¯ USB é¼ æ ‡ã€‚



**æ ¸å¿ƒæ•°æ®ç»“æ„**

`struct input_dev`

```c
struct input_dev {
    const char *name;           // è®¾å¤‡åï¼ˆå¦‚ "gpio-keys"ï¼‰
    const char *phys;           // ç‰©ç†è·¯å¾„ï¼ˆå¦‚ "gpio/0"ï¼‰
    unsigned long evbit[BITS_TO_LONGS(EV_CNT)];     // æ”¯æŒçš„äº‹ä»¶ç±»å‹
    unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];   // æ”¯æŒçš„æŒ‰é”®
    unsigned long relbit[BITS_TO_LONGS(REL_CNT)];   // ç›¸å¯¹åæ ‡ï¼ˆé¼ æ ‡ï¼‰
    unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];   // ç»å¯¹åæ ‡ï¼ˆè§¦æ‘¸å±ï¼‰
    // ... å…¶ä»–å¦‚ swbitï¼ˆå¼€å…³ï¼‰ã€mscbitï¼ˆæ‚é¡¹ï¼‰
};
```





### äº‹ä»¶ç±»å‹

| å®       | è¯´æ˜     | å¸¸è§ç”¨æ³•           |
| -------- | -------- | ------------------ |
| `EV_KEY` | æŒ‰é”®äº‹ä»¶ | æŒ‰é”®ã€å¼€å…³         |
| `EV_REL` | ç›¸å¯¹åæ ‡ | é¼ æ ‡ç§»åŠ¨ï¼ˆdx, dyï¼‰ |
| `EV_ABS` | ç»å¯¹åæ ‡ | è§¦æ‘¸å±ã€æ‘‡æ†       |
| `EV_SW`  | å¼€å…³çŠ¶æ€ | ç¿»ç›–ã€ç”µæºæŒ‰é’®     |
| `EV_MSC` | æ‚é¡¹äº‹ä»¶ | æ‰«æç ç­‰           |



### æŒ‰é”®/åæ ‡ç ï¼ˆ`keybit`, `absbit`ï¼‰

- `KEY_POWER`, `KEY_VOLUMEUP`ï¼ˆå®šä¹‰åœ¨ `include/uapi/linux/input-event-codes.h`ï¼‰
- `ABS_X`, `ABS_Y`, `ABS_MT_POSITION_X`ï¼ˆå¤šç‚¹è§¦æ§ï¼‰



### å¸¸ç”¨å‡½æ•°

#### åˆ†é…ä¸é‡Šæ”¾è®¾å¤‡

```c
struct input_dev *input_allocate_device(void);
void input_free_device(struct input_dev *dev);
```

> âœ… å¿…é¡»æˆå¯¹ä½¿ç”¨ï¼ˆç±»ä¼¼ `kzalloc` / `kfree`ï¼‰ã€‚




#### æ³¨å†Œ/æ³¨é”€è®¾å¤‡

```c
int input_register_device(struct input_dev *dev);
void input_unregister_device(struct input_dev *dev);
```

- `input_register_device()` ä¼šï¼š
  - åˆ†é…æ¬¡è®¾å¤‡å·ï¼ˆ`event0`, `event1`...ï¼‰
  - åˆ›å»º sysfs èŠ‚ç‚¹ï¼ˆ`/sys/class/input/inputX/`ï¼‰
  - é€šçŸ¥äº‹ä»¶å¤„ç†å™¨ï¼ˆå¦‚ `evdev`ï¼‰åˆ›å»º `/dev/input/eventX`

> âœ… **æ¨èä½¿ç”¨ `devm_input_allocate_device()` + è‡ªåŠ¨æ³¨é”€**ã€‚



### è®¾ç½®è®¾å¤‡èƒ½åŠ›ï¼ˆCapabilitiesï¼‰

```c
// è®¾ç½®æ”¯æŒçš„äº‹ä»¶ç±»å‹
__set_bit(EV_KEY, input_dev->evbit);
__set_bit(EV_ABS, input_dev->evbit);

// è®¾ç½®æ”¯æŒçš„æŒ‰é”®
__set_bit(KEY_POWER, input_dev->keybit);
__set_bit(KEY_HOME, input_dev->keybit);

// è®¾ç½®ç»å¯¹åæ ‡èŒƒå›´ï¼ˆå¦‚è§¦æ‘¸å±ï¼‰
input_set_abs_params(input_dev, ABS_X, 0, 1023, 0, 0);
input_set_abs_params(input_dev, ABS_Y, 0, 767, 0, 0);
// å‚æ•°ï¼šdev, axis, min, max, fuzz, flat
```

> âš ï¸ **ä¸è¦ç›´æ¥æ“ä½œ `keybit` æ•°ç»„**ï¼ä½¿ç”¨ `__set_bit()` å®ï¼ˆæ¥è‡ª `asm/bitops.h`ï¼‰ã€‚





### ä¸ŠæŠ¥è¾“å…¥äº‹ä»¶

#### é€šç”¨äº‹ä»¶ä¸ŠæŠ¥

```c
void input_event(struct input_dev *dev, unsigned int type,
                 unsigned int code, int value);
```

- `type`: `EV_KEY`, `EV_REL`, `EV_ABS`...
- `code`: `KEY_POWER`, `ABS_X`...
- `value`:
  - `EV_KEY`: 0=release, 1=press, 2=repeat
  - `EV_ABS`: åæ ‡å€¼ï¼ˆå¦‚ 512ï¼‰
  - `EV_REL`: ç›¸å¯¹å˜åŒ–é‡ï¼ˆå¦‚ +10ï¼‰



#### ä¸“ç”¨ä¸ŠæŠ¥å‡½æ•°ï¼ˆæ¨èï¼‰

```c
// æŒ‰é”®
input_report_key(dev, KEY_POWER, 1);      // æŒ‰ä¸‹
input_report_key(dev, KEY_POWER, 0);      // é‡Šæ”¾

// ç»å¯¹åæ ‡
input_report_abs(dev, ABS_X, 512);
input_report_abs(dev, ABS_Y, 384);

// ç›¸å¯¹åæ ‡
input_report_rel(dev, REL_X, 10);
input_report_rel(dev, REL_Y, -5);

// åŒæ­¥äº‹ä»¶ï¼ˆå¿…é¡»è°ƒç”¨ï¼ï¼‰
input_sync(dev);
```

> âœ… **å¿…é¡»ä»¥ `input_sync()` ç»“æŸä¸€ç»„äº‹ä»¶**ï¼Œè¡¨ç¤ºâ€œå½“å‰äº‹ä»¶åŒ…å·²å®Œæ•´â€ï¼Œç”¨æˆ·ç©ºé—´æ‰ä¼šæ”¶åˆ°ã€‚



#### å¤šç‚¹è§¦æ§ï¼ˆMTï¼‰ä¸ŠæŠ¥ï¼ˆLinux 3.0+ï¼‰

```c
// å¼€å§‹ä¸€ä¸ªè§¦ç‚¹
input_mt_slot(dev, 0);                     // slot 0
input_mt_report_slot_state(dev, MT_TOOL_FINGER, true); // è§¦ç‚¹å­˜åœ¨
input_report_abs(dev, ABS_MT_POSITION_X, 100);
input_report_abs(dev, ABS_MT_POSITION_Y, 200);

// ç¬¬äºŒä¸ªè§¦ç‚¹
input_mt_slot(dev, 1);
input_mt_report_slot_state(dev, MT_TOOL_FINGER, true);
input_report_abs(dev, ABS_MT_POSITION_X, 300);
input_report_abs(dev, ABS_MT_POSITION_Y, 400);

input_sync(dev);
```

> ğŸ“Œ éœ€å…ˆè®¾ç½® MT èƒ½åŠ›ï¼š
>
> ```c
> input_set_capability(dev, EV_ABS, ABS_MT_POSITION_X);
> input_set_capability(dev, EV_ABS, ABS_MT_POSITION_Y);
> input_mt_init_slots(dev, 2, 0); // æ”¯æŒ2ä¸ªè§¦ç‚¹
> ```



### èµ„æºç®¡ç†ï¼ˆæ¨è `devm_` ç‰ˆæœ¬ï¼‰

ä¸ºé¿å…èµ„æºæ³„æ¼ï¼Œä½¿ç”¨ managed resource APIï¼š

```c
static int my_probe(struct platform_device *pdev)
{
    struct input_dev *input;
    int error;

    // è‡ªåŠ¨é‡Šæ”¾ input_dev
    input = devm_input_allocate_device(&pdev->dev);
    if (!input)
        return -ENOMEM;

    input->name = "my-touchscreen";
    input->dev.parent = &pdev->dev;

    __set_bit(EV_ABS, input->evbit);
    input_set_abs_params(input, ABS_X, 0, 4095, 0, 0);
    // ... å…¶ä»–è®¾ç½®

    error = devm_input_register_device(input);
    if (error)
        return error;

    platform_set_drvdata(pdev, input);
    return 0;
}
// é€€å‡ºæ—¶è‡ªåŠ¨è°ƒç”¨ input_unregister_device + input_free_device
```

> âœ… **å¼ºçƒˆæ¨èä½¿ç”¨ `devm_input_allocate_device()` å’Œ `devm_input_register_device()`**ã€‚



### ç”¨æˆ·ç©ºé—´æ¥å£

#### 1. è®¾å¤‡èŠ‚ç‚¹

- `/dev/input/event0`, `/dev/input/event1`, ...
- æƒé™é€šå¸¸ä¸º `crw-rw---- root input`

#### 2. äº‹ä»¶æ ¼å¼ï¼ˆstruct input_eventï¼‰

```c
struct input_event {
    struct timeval time;  // æ—¶é—´æˆ³
    __u16 type;           // EV_KEY, EV_ABS...
    __u16 code;           // KEY_POWER, ABS_X...
    __s32 value;          // çŠ¶æ€å€¼
};
```

#### 3.æµ‹è¯•å·¥å…·

```bash
# æŸ¥çœ‹è®¾å¤‡ä¿¡æ¯
cat /proc/bus/input/devices
# å®æ—¶ç›‘å¬äº‹ä»¶
sudo evtest /dev/input/event0
# æˆ–ä½¿ç”¨ hexdump
sudo od -tx1 -An /dev/input/event0
```



### å®è·µæ¡ˆä¾‹

```dtd
pwr_button {				
    compatible = "rk3399,power-button"; 			
    interrupt-parent = <&gpio0>;//å¯¹åº”çš„ä¸Šçº§ä¸­æ–­æ§åˆ¶å™¨æ˜¯ gpio0													
    interrupts = <5 IRQ_TYPE_EDGE_BOTH>; //ä¸­æ–­å· è§¦å‘æ–¹å¼ GPIO0 A5	
};
```

```c
#include <linux/module.h>
#include <linux/init.h>
#include <linux/platform_device.h>
#include <linux/of.h>												
#include <linux/of_gpio.h>											
#include <linux/gpio.h>															
#include <dt-bindings/gpio/gpio.h>	
#include <linux/interrupt.h>
#include <linux/input.h>

//1.å£°æ˜ä¸€ä¸ªè¾“å…¥è®¾å¤‡å¯¹è±¡çš„æŒ‡é’ˆ
static struct input_dev *button_dev;
static int gpio_button;
static int irqno;

static irqreturn_t button_handler(int irqno, void *dev)
{
	int value;
	value = gpio_get_value(gpio_button);

	if (value) {
		//5.ä¸ŠæŠ¥äº‹ä»¶å¯¹è±¡
		input_report_key(button_dev, KEY_A, 0); //ä¸ŠæŠ¥äº‹ä»¶ é”®å€¼æ¾å¼€0
	} else {
		input_report_key(button_dev, KEY_A, 1); //ä¸ŠæŠ¥äº‹ä»¶ é”®å€¼æŒ‰ä¸‹1
	}
	input_sync(button_dev); //åŒæ­¥äº‹ä»¶,è¡¨ç¤ºä¸ŠæŠ¥å®Œæ¯•
	
	
	printk("call %s() @ %d\n", __func__, __LINE__);
	return IRQ_HANDLED;
}


//å½“å¹³å°è®¾å¤‡å’Œå¹³å°é©±åŠ¨åŒ¹é…æ—¶ä¼šè°ƒç”¨probeå‡½æ•°, å‚æ•°pdevå°±æ˜¯åŒ¹é…ä¸Šå¹³å°è®¾å¤‡å¯¹è±¡
static int button_probe(struct platform_device *pdev)
{
	
	int ret;
	
	//è·å–åŒ¹é…çš„device_nodeå¯¹è±¡
	struct device_node *button_ctrl_node = pdev->dev.of_node;
	
	//2.åˆ›å»ºè¾“å…¥è®¾å¤‡å¯¹è±¡
	button_dev = input_allocate_device();
	if (!button_dev) {
		printk("input_allocate_device fail: Not enough memory\n");
		return -ENOMEM;
	}
	//3.åˆå§‹åŒ–è¾“å…¥è®¾å¤‡å¯¹è±¡
	//set_bit(EV_KEY, button_dev->evbit); //ä¸ºè¾“å…¥è®¾å¤‡å¯¹è±¡è®¾ç½®äº‹ä»¶ç±»å‹ EV_KEY æŒ‰é”®äº‹ä»¶
	button_dev->evbit[0] = BIT_MASK(EV_KEY);

	//set_bit(KEY_A, button_dev->keybit); //ä¸ºè¾“å…¥è®¾å¤‡å¯¹è±¡è®¾ç½®é”®ç  KEY_A
	button_dev->keybit[BIT_WORD(KEY_A)] = BIT_MASK(KEY_A);																										

	button_dev->name = "xyd power key button";
	button_dev->phys = "rk3399 key";
	button_dev->id.vendor = 0x11;
	button_dev->id.product = 0x22;
	button_dev->id.version = 51;
	
	//4.æ³¨å†Œè¾“å…¥è®¾å¤‡å¯¹è±¡
	ret = input_register_device(button_dev);
	if (ret) {
		printk("input_register_device: Failed to register device\n");
		ret = -EBUSY;
		goto err_input_register_device;
	}

	gpio_button = of_get_named_gpio(button_ctrl_node, "gpios", 0);
	if (gpio_is_valid(gpio_button)) {
		printk("gpio_button=%d\n", gpio_button);
	} else {
		printk("of_get_named_gpio_flags fail\n");
		ret= -EINVAL;
		goto err_input_unregister;
	}

	//è·å–ä¸­æ–­å·
	irqno = gpio_to_irq(gpio_button);
	//ç”³è¯·ä¸­æ–­
	if (request_irq(irqno, button_handler, IRQ_TYPE_EDGE_BOTH, "power-key int", NULL)) {
			printk("request irq Can't allocate irq %d\n", irqno);
			ret = -EBUSY;
			goto err_input_unregister;
	}
	
	printk("call %s() @ %d\n", __func__, __LINE__);
	return 0;

err_input_unregister:
	input_unregister_device(button_dev);

err_input_register_device:
	input_free_device(button_dev);
	return ret;
}

//å½“å¹³å°è®¾å¤‡å’Œå¹³å°é©±åŠ¨åˆ†ç¦»æ—¶ä¼šè°ƒç”¨removeå‡½æ•°
static int button_remove(struct platform_device *pdev)
{
	free_irq(irqno, NULL);
	input_unregister_device(button_dev);
	input_free_device(button_dev);

	printk("call %s() @ %d\n", __func__, __LINE__);
	return 0;

}

static const struct of_device_id button_ctrl_match_table[] = {
	{ .compatible = "rk3399,power-button", }, //å’Œè®¾å¤‡èŠ‚ç‚¹compatibleå±æ€§åŒ¹é…
	{}
};

struct platform_driver button_driver = {
	.probe	= button_probe,
	.remove	= button_remove,
	.driver	= {
		.name	= "rk_button", //å¹³å°é©±åŠ¨åç§°,åˆæ˜¯åŒ¹é…æ¡ä»¶
		.of_match_table = button_ctrl_match_table,
	},
};

static int __init drv_mod_init(void) 
{
	printk("call %s() @ %d\n", __func__, __LINE__);
	return platform_driver_register(&button_driver);
}

static void __exit drv_mod_exit(void) 
{
	printk("call %s() @ %d\n", __FUNCTION__, __LINE__);
	platform_driver_unregister(&button_driver);
}

module_init(drv_mod_init);
module_exit(drv_mod_exit);
MODULE_LICENSE("GPL"); 

```





### æ‰©å±•ï¼šè¾“å…¥è®¾å¤‡å±æ€§ï¼ˆsysfsï¼‰

å¯é€šè¿‡ sysfs æŸ¥çœ‹è®¾å¤‡èƒ½åŠ›ï¼š

```bash
# æŸ¥çœ‹æ”¯æŒçš„äº‹ä»¶ç±»å‹
cat /sys/class/input/input0/capabilities/ev
cat /sys/class/input/input0/capabilities/key
```



### æ³¨æ„äº‹é¡¹

#### âœ… æ­£ç¡®åšæ³•

1. **å¿…é¡»è°ƒç”¨ `input_sync()`**ï¼šå¦åˆ™äº‹ä»¶ä¸ä¼šä¸ŠæŠ¥ã€‚
2. **ä½¿ç”¨ `devm_` API**ï¼šé¿å…èµ„æºæ³„æ¼ã€‚
3. **è®¾ç½®åˆç†çš„ `fuzz/flat`**ï¼šç”¨äºæ»¤é™¤å™ªå£°ï¼ˆå¦‚è§¦æ‘¸å±æŠ–åŠ¨ï¼‰ã€‚
4. **å¤šç‚¹è§¦æ§ç”¨ Slot åè®®**ï¼šé¿å…æ—§å¼ `ABS_MT_*` æŠ¥ç‚¹æ··ä¹±ã€‚



## åå…­ã€å°†é©±åŠ¨ç§»æ¤è¿›å†…æ ¸



### æ“ä½œæ­¥éª¤

1. **å°†æµ‹è¯•å¥½çš„é©±åŠ¨ä»£ç æ”¾åˆ°å†…æ ¸ç›®å½•ä¸­**

```bash
lj@ubuntu:~/work/rk3399-android-8.1/kernel/drivers/xyd$ ll
total 12
drwxr-xr-x   2 robin robin 4096 Dec 18 19:39 ./
drwxrwxr-x 137 robin robin 4096 Dec 18 19:37 ../
-rwxr--r--   1 robin robin    0 Dec 18 19:38 button_input_drv.c*
-rwxr--r--   1 robin robin    0 Dec 18 19:39 Kconfig*
-rwxr--r--   1 robin robin   97 Dec 18 19:40 Makefile*
```

2. **ç¼–è¾‘Makefile**

```makefile
#
# Makefile for xyd input button.
#

obj-$(CONFIG_XYD_KEY1_BUTTON)	+= button_input_drv.o


```

3. **æ‹·è´ä¸€ä¸ªKconfigå¹¶ä¿®æ”¹ä¸ºå½“å‰é©±åŠ¨é€‰é¡¹**

```makefile
#
# GPIO subsystem configuration
#

menu "GPIO KEY1 support"

config XYD_KEY1_BUTTON
	tristate "gpio_key1 support"
	---help---
	  gpio key1 supportã€‚

	  dvicestree ->
	  	pwr_button {				
			compatible = "rk3399,power-button"; 			
			gpios = <&gpio0 5 GPIO_ACTIVE_LOW>; 			
		};	


endmenu

```

4. **åœ¨è¯¥é©±åŠ¨ä¸Šçº§ç›®å½•ä¸­è¿›è¡ŒåŒ…å«**

`vim ../Makefile`

```makefile
obj-y				+= xyd/
```

`vim ../Kconfig`

```makefile
source "drivers/xyd/Kconfig"
```

5. **é‡æ–°é…ç½®å†…æ ¸èœå•**

æ ¹æ®ç›®å½•ç»“æ„é€‰ä¸­éœ€è¦å›ºåŒ–çš„é©±åŠ¨ç¨‹åº

6. **ç¼–è¯‘å†…æ ¸**

æ‰§è¡Œç¼–è¯‘å‘½ä»¤

7. **åˆ·å…¥å†…æ ¸åè¿›è¡Œè®¾å¤‡é©±åŠ¨éªŒè¯**

éªŒè¯ç³»ç»Ÿç›®å½•ä¸­æ˜¯å¦å­˜åœ¨è®¾å¤‡å’Œé©±åŠ¨æ–‡ä»¶



### é…ç½®ç»†èŠ‚è¯´æ˜

- Kconfig
  - `tristate`ï¼šæ”¯æŒ `Y`ï¼ˆbuilt-inï¼‰ã€`M`ï¼ˆmoduleï¼‰ã€`N`ï¼ˆdisableï¼‰
    - è‹¥é…ç½®ä¸º `Y`ï¼šé©±åŠ¨ä»£ç ä¼šé“¾æ¥è¿› `vmlinux`
    - è‹¥é…ç½®ä¸º `M`ï¼šç”Ÿæˆ `drivers/char/my_led/my_led.ko`
  - `depends on`ï¼šå£°æ˜ä¾èµ–ï¼ˆå¦‚ `GPIOLIB`, `OF`ï¼‰
  - `help`ï¼šå¸®åŠ©æ–‡æœ¬ï¼ˆä¼šåœ¨ menuconfig ä¸­æ˜¾ç¤ºï¼‰
- Makefile
  - `CONFIG_MY_LED` æ˜¯ Kconfig ä¸­å®šä¹‰çš„é€‰é¡¹
  - å½“é…ç½®ä¸º `Y` æ—¶ï¼Œ`obj-y += my_led.o` â†’ ç¼–è¯‘è¿›å†…æ ¸
  - å½“é…ç½®ä¸º `M` æ—¶ï¼Œ`obj-m += my_led.o` â†’ ç¼–è¯‘ä¸ºæ¨¡å—
  - æœ«å°¾çš„ `/` è¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ªå­ç›®å½•ã€‚



## åä¸ƒã€å®‰å“ç³»ç»Ÿå¼€å‘



### å®‰å“åˆ·æœº

1.æŸ¥çœ‹ç¼–è¯‘è„šæœ¬

```bash
robin@ubuntu:~/work/rk3399-android-8.1$ ll build-nanopc-t4.sh
lrwxrwxrwx 1 robin robin 41 May 15  2021 build-nanopc-t4.sh -> device/rockchip/rk3399/build-nanopc-t4.sh*
```

2.è¿è¡Œè„šæœ¬

```bash
robin@ubuntu:~/work/rk3399-android-8.1$ ./build-nanopc-t4.sh -h
Usage: ./build-nanopc-t4.sh [ARGS]

Options:
  -a         build Android
  -B         build U-Boot
  -K         build Linux kernel
  -W         build Wi-Fi drivers (.ko)

  -F, --all  build all (U-Boot, kernel, wifi, Android)
  -M         make rockdev image
  -u         generate update.img

  -h         show this help message and exit

```

3.å®Œå…¨ç¼–è¯‘

```bash
robin@ubuntu:~/work/rk3399-android-8.1$ ./build-nanopc-t4.sh -F -M
```

4.ä½¿ç”¨å®˜æ–¹å·¥å…·åˆ·å…¥å›ºä»¶

```bash
robin@ubuntu:~/work/rk3399-android-8.1$ ll rockdev/
total 12
drwxrwxr-x  3 robin robin 4096 Dec 18 19:15 ./
drwxr-xr-x 40 robin robin 4096 Oct 26 23:49 ../
drwxrwxr-x  2 robin robin 4096 Dec 18 19:15 Image-nanopc_t4/      #å›ºä»¶ç›®å½•
```



### ç¼–è¯‘å®‰å“ç”¨æˆ·æ€Cç¨‹åº



1.**åˆ›å»ºä¸€ä¸ª`Android.mk`æ–‡ä»¶å¹¶æ·»åŠ å¦‚ä¸‹å†…å®¹**

```makefile
# Copyright 2006 The Android Open Source Project

#è·å–å½“å‰è·¯å¾„
LOCAL_PATH:= $(call my-dir)
#æ¸…ç©ºä»¥LOCAL_å¼€å¤´çš„å˜é‡ï¼ŒLOCAL_PATHé™¤å¤–
include $(CLEAR_VARS)
#æŒ‡å®šæºæ–‡ä»¶
LOCAL_SRC_FILES:= \
	button_input_test.c
#åœ¨ä»»ä½•æƒ…å†µéƒ½ä¼šç¼–è¯‘è¿™ä¸ªæ¨¡å—
LOCAL_MODULE_TAGS := optional
#æŒ‡å®šç›®æ ‡æ–‡ä»¶
LOCAL_MODULE:= button_input_test_elf
#ç¼–è¯‘æˆå¯æ‰§è¡Œç¨‹åº
include $(BUILD_EXECUTABLE)

```

2.å°†ç”¨æˆ·æ€æºç å¤åˆ¶åˆ°Androidç›®å½•ä¸‹

3.é…ç½®ç¼–è¯‘ç¯å¢ƒ

```bash
robin@ubuntu:~/work/rk3399-android-8.1$ source build/envsetup.sh    #åŠ è½½å˜é‡åˆ°ç¯å¢ƒ
including device/rockchip/rk3399/vendorsetup.sh
including sdk/bash_completion/adb.bash

robin@ubuntu:~/work/rk3399-android-8.1$lunch             #é€‰æ‹©è¿è¡Œç¯å¢ƒ
```

4.å¼€å§‹ç¼–è¯‘

```bash
robin@ubuntu:~/work/rk3399-android-8.1$ mmm .button/
[100% 488/488] Install: out/target/product/rk3399/system/bin/button_input_test_elf
```

5.å°†ç¼–è¯‘å‡ºçš„ç¨‹åºä¼ åˆ°å¼€å‘æ¿ä¸­

```bash
adb root
adb disable-verity
adb reboot
adb root
adb remount
adb push ./out/target/product/rk3399/system/bin/button_input_test_elf /system
```

èµ‹äºˆæ‰§è¡Œæƒé™å³å¯åœ¨Androidä¸­è¿è¡Œç¨‹åº



