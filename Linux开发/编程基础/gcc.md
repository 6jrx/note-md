# GCC常用指令

## 🚀基础编译选项

***

* **`-Wall`** : 分成两部分`-W`+`all`, 检测程序中各种问题

```bash
$ gcc -Wall hello.c -o hello
```

![截图](pic/001.png)

> 不需要编译`.h`文件，因为`.h`文件在`.c`文件里显式包含了，代码检查时会自动引入编译

***

* **`-v`** : 显示编译过程信息

```bash
$ gcc -Wall -v hello.c main.c -o test
```

![截图](pic/002.png)

***

* **`-c`** : 执行‘预处理’‘汇编’‘编译’步骤，生成`.o`文件

```bash
$ gcc -Wall -c main.c hello.c
```

![截图](pic/003.png)

> 无需添加`-o`选项，`-o`会调用链接器生成目标可执行文件

```bash
$ gcc main.o hello.o -o test
```

> 这里无需`-Wall`，因为`-Wall`是检查编译过程中的问题，这里只执行了链接操作

### ❗编译次序问题

> 主要针对一些比较老的编辑器

  + gcc检测文件是从右往左
  + 某个源文件需要依赖另一个源文件时需要把依赖放在前面(右边)

## 🎉库文件

> 多个目标文件`.o`打包到一个文件里，标准库一般位于`/usr/lib`、`/lib`、`/usr/local/lib`目录里，以`.a`为后缀名

 * 静态库 : 在类unix系统里一般以`.a`文件为主，windows中一般以`.lib`文件为主
 * 动态库 : 在linux中是`.so`文件，在windows中是`.dll`文件

### 🔗链接外部静态库

> 通过在命令中添加库文件的路径(一般是相对路径)来引入外部库依赖

1. 显式指定外部库文件

```bash
$ gcc -Wall main.c /usr/lib/libm.a -o calc
```

> ⚠️注意: 指定库文件是，需要注意文件依赖顺序(右->左)

2. 使用`-l`选项指定外部库文件

```bash
$ gcc -Wall main.c -lm -o calc
```

这里的`-lm`也是一个组合选项，从系统库目录找文件，表示链接标准库目录`/usr/lib`

> ⚠️注意: 在使用库文件里面的函数时需要在源代码中包含使用到的库函数的头文件，就算你手动链接了目标函数的库文件，也会报错，因为需要显式声明

3. 指定外部库目录(✨推荐)

不需要外部环境依赖，一般在项目目录里创建目录

* **`-I`** : 指定头文件搜索目录

* **`-L`** : 指定库文件搜索目录

4. 设置系统环境变量

* **`C_INCLUDE_PATH`** : 指定头文件目录

* **`LIBRARY_PATH`** : 指定库文件目录


#### 🔧手动创建库文件

+ 创建库

```bash
$ ar cr lib_name.a file1.o file2.o file3.o
```

+ 查看库文件里有多少个目标文件
```bash
$ ar t lib_name.a
```

### 😄链接动态库

> ⚠️注意：如果有两个内容一样的库，分别被编译成静态库和动态库，GCC在都被指定时，系统会优先使用动态库来链接

1. 指定环境变量

程序在执行的时候会从这个环境变量指定的目录寻找动态库文件

* **`LD_LIBRARY_PATH`** : 配置动态库文件目录的环境变量

```bash
$ export LD_LIBRARY_PATH=/home/xxx/lib
```

## 👨‍💻C标准指定

通常不同C标准编译时，编译器识别的c关键字不同，包含不同的功能。所以在编译时针对不同标准的源代码需要指定编译标准

通常情况下使用c99标准

* **`-ansi`** : 使用ansi标准来编译（标准C）

* **`-c99`** : 使用c99标准来编译（升级版）

```bash
$ gcc -Wall -ansi -c main.c
```

或者

```bash
$ gcc -Wall -std=c99 -c main.c
```

> 还有很多其他细节指定选项等用到的时候再去查，比如：
> `-Wcomment`
> `-Wformat`
> `-Wunused`
> `-Wimplicit`
> `-Wreturn-type`


## ⚓预处理宏

GCC编译是会对#开头的行检测是否宏关键字，执行相关语义的编译操作

### 🦽宏定义

* **`-D`** : 宏定义选项，在编译时指定一个宏

```bash
$ gcc -Wall -DNUM=123 main.c -o test
```

> 在编译是会将指定的宏替换到代码中，效果相当于：`#define NUM 123`

宏表达式

```bash
$ gcc -Wall -DSUM="1+2" main.c -o test
```

什么都不写

```bash
$ gcc -Wall -DFLAG main.c -o test
```

> 这里相当于`#define FLAG 1`，因为定义了一个空的宏时，默认值就是1

* **`-E`** : 可以将指定源码里的宏替换为宏定义的值(宏展开)，在分析复杂代码时很有用

```bash
$ gcc -Wall -E main.c
```

> 这个过程只做宏替换后输出(预处理步骤)，不编译


* **`-save-temps`** : 保存编译过程文件

```bash
$ gcc -Wall -save-temps -c main.c
```

> 此选项会将编译过程临时文件预处理结果保存到`.i`文件中，将汇编结果保存到`.s`文件中

### 🚲条件编译

* **`#if`** : 如果常量表达式为真，则编译后续代码至`#endif`等指令之间的代码块

* **`#elif`** : 类似于 else if，用于提供多个编译条件分支

* **`#else`** : 用于 `#if`、`#ifdef`或 `#ifndef`的最后一个分支

* **`#endif`** : 结束一个条件编译块

* **`#ifdef`** : 如果指定的宏已定义，则编译后续代码

* **`#ifndef`** : 如果指定的宏未定义，则编译后续代码

* **`#defined`** : 可在 `#if`或 `#elif`中使用的运算符，用于检查宏是否已定义


## 🐛编译调试

* **`-g`** : 在目标可执行文件中生成一些调试的信息

| 选项   | 描述                                                                                  |
| :----- | :------------------------------------------------------------------------------------------------- |
| **-g** | **默认级别**。生成标准调试信息，通常包括变量、行号、函数等基本信息。在大多数 Linux 系统上，默认生成 DWARF 格式的调试信息 。 |
| **-g0** | **不生成任何调试信息**。相当于完全没有 `-g` 选项 。                                              |
| **-g1** | **生成最少的调试信息**。仅包含基本的行号和函数信息，不包括变量描述等细节。可能无法查看所有变量的值 。        |
| **-g2** | 与 `-g` 相同，生成**完整的标准调试信息**（包括变量和行号等），推荐用于大多数调试场景 。                      |
| **-g3** | 生成**最详细的调试信息**，除了 `-g2` 包含的所有内容外，还包括**宏定义信息**。这使得在 GDB 中可以查看和展开宏 。 |


```bash
$ gcc -Wall -g main.c -o test
```

| 场景                           | 推荐编译选项                     |
| :----------------------------- | :------------------------------- |
| **常规调试**                   | `-g` 或 `-g2`                    |
| **需要调试宏**                 | `-g3`                            |
| **希望调试时代码更易理解**     | `-g -O0` (默认)                  |
| **希望在调试时也有较好性能**   | `-g -Og`                         |
| **需要检查汇编或极致性能调试** | `-g -O2` (注意优化可能影响调试)  |
| **生成最终发布版本**           | 不加 `-g`，或编译后使用 `strip` |

* **`ulimit`命令** ： 可用于配置系统生成程序崩溃瞬间的内存信息

该命令用来解除coredump大小限制

> `coredump`核心转储文件，程序执行的尸体。在内存中执行的程序因为错误挂掉了，会生成该文件。用于帮助开发者定位程序崩溃原因。通常使用GDB分析

> 注意；如果解除了大小限制，主机磁盘有可能被写满

```bash
$ ulimit -c unlimited
$ gdb <程序名> <coredump文件>
```

| 选项 | 含义                                                         | 单位                  |
| :--- | :----------------------------------------------------------- | :-------------------- |
| `-a` | **显示当前所有资源的限制设置**                               | -                     |
| `-c` | 设置 **core 文件** 的最大大小（常用于程序调试）              | 512 字节块 (blocks)   |
| `-f` | 设置 Shell **可创建文件**的最大大小                          | 512 字节块 (blocks)   |
| `-n` | 设置进程可以**同时打开的文件描述符**的最大数量（非常重要）     | 个数                  |
| `-s` | 设置进程的**堆栈**的最大大小                                  | KB                    |
| `-t` | 设置进程允许使用的最大 **CPU 时间**                          | 秒                    |
| `--u` | 设置用户最多可运行的**进程数目**                             | 个数                  |
| `-l` | 设置进程可以**锁定在内存中**的最大大小                       | KB                    |
| `-v` | 设置进程可使用的**虚拟内存**的最大大小                       | KB                    |
| `-H` | 设置指定资源的**硬限制**（严格上限，通常只有 root 可提高）    |                       |
| `-S` | 设置指定资源的**软限制**（实际生效的限制，用户可调整直至硬限制） |                       |

![截图](pic/004.png)
